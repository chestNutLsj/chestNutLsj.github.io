<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Linux Shell 学习笔记（一） | chestNut_Lsj's Blog</title><meta name="keywords" content="Shell,Linux"><meta name="author" content="chestNut_Lsj,chestnut_lsj@foxmail.com"><meta name="copyright" content="chestNut_Lsj"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux Shell学习笔记 本篇Shell环境基于Arch Linux 5.15.12；GNU bash，版本 5.1.12(1)-release (x86_64-pc-linux-gnu) 学习资料基于快乐的Linux命令行，本书是The Linux Command Line的中文版。虽然大体的翻译比较贴切，但仍不免有些部分翻译比较生硬或缺乏逻辑，笔者在写博客时对这些进行了一定的改善，如果在">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux Shell 学习笔记（一）">
<meta property="og:url" content="https://chestnutlsj.github.io/2022/01/06/Linux-Shell-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="chestNut_Lsj&#39;s Blog">
<meta property="og:description" content="Linux Shell学习笔记 本篇Shell环境基于Arch Linux 5.15.12；GNU bash，版本 5.1.12(1)-release (x86_64-pc-linux-gnu) 学习资料基于快乐的Linux命令行，本书是The Linux Command Line的中文版。虽然大体的翻译比较贴切，但仍不免有些部分翻译比较生硬或缺乏逻辑，笔者在写博客时对这些进行了一定的改善，如果在">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chestnutlsj.github.io/img/violet3.jpg">
<meta property="article:published_time" content="2022-01-06T12:00:00.000Z">
<meta property="article:modified_time" content="2022-01-07T15:14:32.305Z">
<meta property="article:author" content="chestNut_Lsj">
<meta property="article:tag" content="Shell">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chestnutlsj.github.io/img/violet3.jpg"><link rel="shortcut icon" href="/img/mylogo.png"><link rel="canonical" href="https://chestnutlsj.github.io/2022/01/06/Linux-Shell-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?ccfb5a8d496379d5235ea606a626caff";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: chestNut_Lsj","link":"链接: ","source":"来源: chestNut_Lsj's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux Shell 学习笔记（一）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-07 23:14:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/scroll_bars.css"><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="chestNut_Lsj's Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/violet_avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fas fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" href="/myself/"><i class="fa-fw fas fa-id-card"></i><span> Myself</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/violet3.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">chestNut_Lsj's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fas fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" href="/myself/"><i class="fa-fw fas fa-id-card"></i><span> Myself</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux Shell 学习笔记（一）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-06T12:00:00.000Z" title="发表于 2022-01-06 20:00:00">2022-01-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-07T15:14:32.305Z" title="更新于 2022-01-07 23:14:32">2022-01-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Shell/">Shell</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">32.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>122分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux Shell 学习笔记（一）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1><code>Linux Shell</code>学习笔记</h1>
<p>本篇<code>Shell</code>环境基于Arch Linux 5.15.12；GNU bash，版本 5.1.12(1)-release (x86_64-pc-linux-gnu)</p>
<p>学习资料基于<a target="_blank" rel="noopener" href="https://billie66.github.io/TLCL/">快乐的Linux命令行</a>，本书是<a target="_blank" rel="noopener" href="http://linuxcommand.org/">The Linux Command Line</a>的中文版。虽然大体的翻译比较贴切，但仍不免有些部分翻译比较生硬或缺乏逻辑，笔者在写博客时对这些进行了一定的改善，如果在阅读时仍感觉到逻辑缺失，可以去查看<a target="_blank" rel="noopener" href="https://billie66.github.io/TLCL/book/">英文原版</a>。</p>
<p>本篇是学习 shell 的第一部分——了解什么是shell以及shell的一些基本命令。</p>
<h2 id="一、什么是shell？">一、什么是shell？</h2>
<p>shell本身即是一个程序，接受从键盘输入的命令然后交由系统执行。几乎所有Linux发行版都提供一个名为 bash 的来自GNU项目的shell程序，bash是“Bourne Again SHell”的缩写，即bash是最初Unix上由Steve Bourne写成的shell程序的加强版。</p>
<h3 id="1-1终端仿真器">1.1	终端仿真器</h3>
<p>即<code>terminal</code>，在不同的系统或桌面上可能有不同的称呼，笔者使用的KDE桌面环境中默认是Konsole。</p>
<h3 id="1-2启动">1.2	启动</h3>
<p>默认快捷键是<kbd>ctrl</kbd>+<kbd>alt</kbd>+<kbd>T</kbd>，在黑色窗口内可以看到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ </span><br></pre></td></tr></table></figure>
<p>这被称为<code>shell提示符</code>，通常包括<code>用户名@主机名</code>，之后是当前工作目录。</p>
<p>如果提示符最后一个字符是#，代表着当前终端会话拥有管理员权限，而$则代表普通用户权限。</p>
<h3 id="1-3方向键的作用">1.3	方向键的作用</h3>
<p>使用向上箭头（向下箭头）可以看到上一条（下一条）执行过的命令重新出现，而Linux大多默认保存输入过的500个命令。</p>
<p>左右箭头则可以移动光标位置。</p>
<h3 id="1-4鼠标作用">1.4	鼠标作用</h3>
<p>快速粘贴：按下鼠标左键，高亮文本会被拷贝到一个缓冲区，按下鼠标中键，这些文本就会被粘贴到光标位置。</p>
<p>注意：不要使用<kbd>ctrl</kbd>+<kbd>c</kbd>或者<kbd>ctrl</kbd>+<kbd>v</kbd>进行shell内复制与粘贴，事实上，在Microsoft Windows为这两个组合键赋予复制粘贴含义之前，shell就已经用这两个控制代码工作了。</p>
<p>在GUI桌面环境中修改窗口管理程序的鼠标聚焦策略为“聚焦跟随着鼠标”，可以实现鼠标移动到一个窗口的上方即能接受输入，而直到单击窗口之前它都不会成为前端窗口，这样可以使拷贝和粘贴更方便。</p>
<h3 id="1-5尝试一些简单命令">1.5	尝试一些简单命令</h3>
<p><code>date</code>：获取当前日期；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ date</span><br><span class="line">2022年 01月 02日 星期日 01:32:27 CST</span><br></pre></td></tr></table></figure>
<p><code>cal</code>：显示当前月份的日历；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ cal</span><br><span class="line">      一月 2022     </span><br><span class="line">一 二 三 四 五 六 日</span><br><span class="line">                1  2</span><br><span class="line"> 3  4  5  6  7  8  9</span><br><span class="line">10 11 12 13 14 15 16</span><br><span class="line">17 18 19 20 21 22 23</span><br><span class="line">24 25 26 27 28 29 30</span><br><span class="line">31                  </span><br></pre></td></tr></table></figure>
<p><code>df</code>：查看磁盘剩余空间的数量；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ df</span><br><span class="line">文件系统           1K-块     已用      可用 已用% 挂载点</span><br><span class="line">dev              8106044        0   8106044    0% /dev</span><br><span class="line">run              8116556     1744   8114812    1% /run</span><br><span class="line">/dev/nvme0n1p2 102626232 14684352  82682616   16% /</span><br><span class="line">tmpfs            8116556     7512   8109044    1% /dev/shm</span><br><span class="line">tmpfs            8116560     7064   8109496    1% /tmp</span><br><span class="line">/dev/nvme0n1p3 153707984 12242016 133585264    9% /home</span><br><span class="line">/dev/nvme0n1p1    817584      300    817284    1% /efi</span><br><span class="line">tmpfs            1623308       60   1623248    1% /run/user/1000</span><br><span class="line">/dev/nvme0n1p4 237142012 47968640 189173372   21% /run/media/lsjarch/Reserve</span><br></pre></td></tr></table></figure>
<p><code>free</code>：显示空闲内存的数量；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ free</span><br><span class="line">               total        used        free      shared  buff/cache   available</span><br><span class="line">内存：   16233116     1982848    10264700      706376     3985568    13202404</span><br><span class="line">交换：    4194300           0     4194300</span><br></pre></td></tr></table></figure>
<p><code>exit</code>：结束当前终端会话；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ exit</span><br></pre></td></tr></table></figure>
<h3 id="1-6虚拟终端">1.6	虚拟终端</h3>
<p>即使<code>terminal</code>没有在运行，后台仍会有虚拟终端会话运行，可以通过<kbd>ctrl</kbd>+<kbd>alt</kbd>+<kbd>F2</kbd>~<kbd>F6</kbd>访问。</p>
<p>当一个会话被访问时，显示登录提示框，需要输入用户名和密码，要切换一个虚拟控制台到另一个，按下<kbd>alt</kbd>+<kbd>F2</kbd>~<kbd>F6</kbd>中的一个，要返回图形界面，则<kbd>alt</kbd>+<kbd>F1</kbd>。</p>
<h3 id="1-7拓展阅读">1.7	拓展阅读</h3>
<ul>
<li>更多关于bash之父Steve Bourne的故事：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Steve_Bourne">https://en.wikipedia.org/wiki/Steve_Bourne</a></li>
<li>一篇介绍计算机领域shell概念的文章：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Shell_(computing)">https://en.wikipedia.org/wiki/Shell_(computing)</a></li>
</ul>
<hr>
<h2 id="二、文件系统中跳转">二、文件系统中跳转</h2>
<p>本章命令：<code>pwd</code>, <code>ls</code>, <code>cd</code>。</p>
<h3 id="2-1理解文件系统树">2.1	理解文件系统树</h3>
<p>Linux以分层目录结构来组织所有文件，即树型目录。这个目录树可以包含其他文件或目录。文件系统中第一级目录称为根目录，根目录包含文件和子目录，而子目录包含文件和更多子目录。</p>
<p>与Windows为每个存储设备建立一个独自的文件系统不同，Linux（及其他类Unix系统）总是只有一个单一的文件系统树，而不论有多少存储设备连接到计算机上。即存储设备自由地挂载到目录树的各个节点上。</p>
<h3 id="2-2当前工作目录">2.2	当前工作目录</h3>
<p><code>pwd</code>：print working directory的缩写，显示当前工作目录；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ pwd</span><br><span class="line">/home/lsjarch</span><br></pre></td></tr></table></figure>
<p>首次启动<code>terminal</code>时，当前工作目录是家目录，而普通用户只对家目录拥有权限进行文件写入。</p>
<h3 id="2-3列出目录内容">2.3	列出目录内容</h3>
<p><code>ls</code>：列出一个目录包含的文件及子目录；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ ls</span><br><span class="line">Desktop  Documents  Downloads  Music  Pictures  Public  Templates  Videos  yay-bin-11.0.2-1-x86_64.pkg.tar.zst</span><br></pre></td></tr></table></figure>
<p>事实上，<code>ls</code>可以列出任一个目录的内容。</p>
<h3 id="2-4切换当前目录">2.4	切换当前目录</h3>
<p><code>cd</code>：切换当前工作目录到目标目录，目标目录通过两种方式指定：绝对路径，相对路径；</p>
<ul>
<li>
<p>*绝对路径：*开始于根目录，紧跟着目录树的一个个分支一直到达目标文件或目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ cd /usr/bin</span><br><span class="line">[lsjarch@LsjsArch bin]$ pwd</span><br><span class="line">/usr/bin</span><br><span class="line">[lsjarch@LsjsArch bin]$ ls</span><br><span class="line"><span class="meta">#</span><span class="bash"> ... Listing of lots of files ...</span></span><br></pre></td></tr></table></figure>
<p>通常，shell提示符会自动显示工作目录名；</p>
</li>
<li>
<p>*相对路径：*开始于当前目录，<code>.</code> 表示当前目录 ，<code>..</code> 表示父目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ cd /usr/bin</span><br><span class="line">[lsjarch@LsjsArch bin]$ pwd</span><br><span class="line">/usr/bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前工作目录为/usr/bin，要切换到父目录/usr</span></span><br><span class="line">[lsjarch@LsjsArch bin]$ cd ..</span><br><span class="line">[lsjarch@LsjsArch usr]$ pwd</span><br><span class="line">/usr</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前工作目录为/usr，要切换到子目录/usr/bin</span></span><br><span class="line">[lsjarch@LsjsArch usr]$ cd ./bin</span><br><span class="line">[lsjarch@LsjsArch bin]$ pwd</span><br><span class="line">/usr/bin</span><br></pre></td></tr></table></figure>
<p>事实上，<code>./</code>总是可以被省略，如果不指定文件目录，则当前工作目录作为默认工作目录。</p>
</li>
</ul>
<p><strong>一些快速切换当前工作目录的快捷命令：</strong></p>
<p><code>cd</code>：更改当前工作目录到家目录；</p>
<p><code>cd -</code>：更改当前工作目录到先前工作目录；</p>
<p><code>cd ~user_name</code>：更改当前工作目录到用户家目录；</p>
<h3 id="2-5Linux文件名的一些规则">2.5	Linux文件名的一些规则</h3>
<ol>
<li>
<p>&quot;<code>.</code>&quot;开头的文件是隐藏文件，<code>ls</code>命令无法直接列出，而<code>ls -a</code>命令可以。创建用户后，家目录下会存在几个配置帐号的隐藏文件，用来定制系统环境。某些应用程序也会将配置文件以隐藏文件的形式存放在家目录下面；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ ls -a</span><br><span class="line">.              .bash_profile  Desktop     .icons  .mozilla  Postman          .themes   .wget-hsts</span><br><span class="line">..             .bashrc        Documents   .java   Music     Public           Videos    .Xauthority</span><br><span class="line">.bash_history  .cache         Downloads   .kde4   Pictures  .python_history  .viminfo  .xprofile</span><br><span class="line">.bash_logout   .config        .gtkrc-2.0  .local  .pki      Templates        .vscode   yay-bin-11.0.2-1-x86_64.pkg.tar.zst</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>文件名和命令名在Linux中是大小写敏感的，这与Windows不同；</p>
</li>
<li>
<p>Linux没有“文件扩展名”的概念，类Unix的操作系统不以文件扩展名来决定文件的内容或用途，但某些应用程序会；</p>
</li>
<li>
<p>文件名中以下划线作为连接符，且不要使用空格。</p>
</li>
</ol>
<hr>
<h2 id="三、探索Linux">三、探索Linux</h2>
<p>本章命令：<code>ls</code>, <code>file</code>, <code>less</code>。</p>
<h3 id="3-1ls深入">3.1	<code>ls</code>深入</h3>
<p><code>ls</code>可以指定要列出内容的目录；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ ls /usr</span><br><span class="line">bin  include  lib  lib32  lib64  local  sbin  share  src</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出多个目录的内容，以空格分隔</span></span><br><span class="line">[lsjarch@LsjsArch ~]$ ls /usr /home</span><br><span class="line">/home:</span><br><span class="line">lost+found  lsjarch</span><br><span class="line"></span><br><span class="line">/usr:</span><br><span class="line">bin  include  lib  lib32  lib64  local  sbin  share  src</span><br></pre></td></tr></table></figure>
<p>可以改变输出格式以得到更多细节，<code>ls</code>命令的<code>-l</code>选项，会将结果以长模式输出；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ ls -l</span><br><span class="line">总用量 2948</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch    4096  1月  2 02:49 Desktop</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch    4096 12月 28 18:41 Documents</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch    4096  1月  2 01:08 Downloads</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch    4096 12月 28 18:41 Music</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch    4096 12月 28 18:41 Pictures</span><br><span class="line">drwxr-xr-x 3 lsjarch lsjarch    4096  1月  2 02:19 Postman</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch    4096 12月 28 18:41 Public</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch    4096 12月 28 18:41 Templates</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch    4096 12月 28 18:41 Videos</span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch 2981132 12月 28 11:46 yay-bin-11.0.2-1-x86_64.pkg.tar.zst</span><br></pre></td></tr></table></figure>
<p>使用<code>--help</code>参数获取其他参数的使用说明</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ ls --help</span><br><span class="line">用法：ls [选项]... [文件]...</span><br><span class="line">列出给定文件（默认为当前目录）的信息。</span><br><span class="line">如果不指定 -cftuvSUX 中任意一个或--sort 选项，则根据字母大小排序。</span><br><span class="line"></span><br><span class="line">必选参数对长短选项同时适用。</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下面列出最常用的一些命令，其余的随用随看</span></span><br><span class="line">  -a, --all                  不隐藏任何以 . 开始的项目</span><br><span class="line">  -A, --almost-all           列出除 . 及 .. 以外的任何项目</span><br><span class="line">      --author               与 -l 同时使用时，列出每个文件的作者</span><br><span class="line">  </span><br><span class="line">  -d, --directory            当遇到目录时列出目录本身而非目录内的文件</span><br><span class="line">  -D, --dired                产生适合 Emacs 的 dired 模式使用的结果</span><br><span class="line">  -f                         list all entries in directory order</span><br><span class="line">  -F, --classify[=WHEN]      append indicator (one of */=&gt;@|) to entries; WHEN can be &#x27;always&#x27; (default if omitted), &#x27;auto&#x27;, or &#x27;never&#x27;</span><br><span class="line">      --file-type            likewise, except do not append &#x27;*&#x27;</span><br><span class="line">      --format=WORD          across -x, commas -m, horizontal -x, long -l, single-column -1, verbose -l, vertical -C</span><br><span class="line">      --full-time            like -l --time-style=full-iso</span><br><span class="line">  </span><br><span class="line">  -h, --human-readable       与 -l 和 -s 一起，以易于阅读的格式输出文件大小（例如 1K 234M 2G等）</span><br><span class="line">      --si                   同上面类似，但是使用 1000 为基底而非 1024</span><br><span class="line">      </span><br><span class="line">  -i, --inode                显示每个文件的索引编号（inode 号）</span><br><span class="line">  -I, --ignore=模式          不显示任何匹配指定 shell &lt;模式&gt;的项目</span><br><span class="line"></span><br><span class="line">  -l                         使用较长格式列出信息</span><br><span class="line">  -L, --dereference          当显示符号链接的文件信息时，显示符号链接所指示的对象而并非符号链接本身的信息</span><br><span class="line">  -m                         所有项目以逗号分隔，并填满整行行宽</span><br><span class="line">  </span><br><span class="line">  -q, --hide-control-chars   以“?”字符代替无法打印的字符</span><br><span class="line">      --show-control-chars   原样显示无法打印的字符（这是默认行为，除非被调用本程序的名称是“ls”而且是在终端中进行输出）</span><br><span class="line">  </span><br><span class="line">  -r, --reverse              逆序排列</span><br><span class="line">  -R, --recursive            递归显示子目录</span><br><span class="line">  -s, --size                 以块数形式显示每个文件分配的尺寸</span><br><span class="line">  -S                         sort by file size, largest first</span><br><span class="line">      --sort=WORD            sort by WORD instead of name: none (-U), size (-S), time (-t), version (-v), extension (-X), width</span><br><span class="line">      --time=WORD            change the default of using modification times; access time (-u): atime, access, use; change time (-c): ctime, status;</span><br><span class="line">                             birth time: birth, creation; with -l, WORD determines which time to show; with --sort=time, sort by WORD (newest first)</span><br><span class="line">      --time-style=TIME_STYLE  使用 -l 时显示的时间/日期格式；请见下面TIME_STYLE 的相关内容</span><br><span class="line">  -t                         按时间排序，最新的最前；参见 --time</span><br><span class="line">  -T, --tabsize=COLS         指定制表符（Tab）的宽度，而非默认8字符</span><br><span class="line">  -u                         同 -lt 一起使用：按照访问时间排序并显示；同 -l 一起使用：显示访问时间并按文件名排序。其它：按照访问时间排序，最新的最靠前</span><br><span class="line">  -U                         不进行排序；按照目录顺序列出项目</span><br><span class="line">  -v                         在文本中进行数字（版本）的自然排序</span><br><span class="line">  </span><br><span class="line">  -1                         list one file per line</span><br><span class="line">      --help            	显示此帮助信息并退出</span><br><span class="line">      --version         	显示版本信息并退出</span><br></pre></td></tr></table></figure>
<h3 id="3-2选项和参数">3.2	选项和参数</h3>
<p>命令名经常会有一个更正命令行为的选项，会带有一个或多个参数作为命令作用的对象；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command ~options arguments</span><br></pre></td></tr></table></figure>
<p>选项有长选项短选项之分，很多命令支持多个短选项串在一起使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ ls -lt --reverse</span><br><span class="line">总用量 2948</span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch 2981132 12月 28 11:46 yay-bin-11.0.2-1-x86_64.pkg.tar.zst</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch    4096 12月 28 18:41 Videos</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch    4096 12月 28 18:41 Templates</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch    4096 12月 28 18:41 Public</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch    4096 12月 28 18:41 Pictures</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch    4096 12月 28 18:41 Music</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch    4096 12月 28 18:41 Documents</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch    4096  1月  2 01:08 Downloads</span><br><span class="line">drwxr-xr-x 3 lsjarch lsjarch    4096  1月  2 02:19 Postman</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch    4096  1月  2 03:23 Desktop</span><br></pre></td></tr></table></figure>
<h3 id="3-3深究长格式输出">3.3	深究长格式输出</h3>
<p>参照3.2中的输出，分析各字段含义：</p>
<ul>
<li>
<p><code>-rw-r--r--</code>：文件的访问权限。</p>
<ul>
<li>第一个字符指明文件类型，“<code>-</code>”表示普通文件，“<code>d</code>”表示目录；</li>
<li>之后三个字符表示文件所有者的访问权限，如<code>rw-</code>、<code>rwx</code>；</li>
<li>再之后三个字符表示文件所属组中成员的访问权限，如<code>r--</code>、<code>r-x</code>；</li>
<li>最后三个字符表示其他所有人的访问权限，如<code>r--</code>、<code>r-x</code>；</li>
</ul>
</li>
<li>
<p><code>1</code>：文件的硬链接数目；</p>
</li>
<li>
<p><code>lsjarch</code>：文件属主的用户名；</p>
</li>
<li>
<p><code>lsjarch</code>：文件所属用户组的名字；</p>
</li>
<li>
<p><code>2981132</code>：以字节数表示的文件大小；</p>
</li>
<li>
<p><code>12月28 11:46</code>：上次修改文件的时间和日期；</p>
</li>
<li>
<p><code>yay...</code>：文件名</p>
</li>
</ul>
<h3 id="3-4确定文件类型">3.4	确定文件类型</h3>
<p><code>file</code>：打印出文件内容的简单描述；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ ls</span><br><span class="line">Desktop  Documents  Downloads  Music  Pictures  Postman  Public  Templates  Videos  yay-bin-11.0.2-1-x86_64.pkg.tar.zst</span><br><span class="line">[lsjarch@LsjsArch ~]$ file yay-bin-11.0.2-1-x86_64.pkg.tar.zst </span><br><span class="line">yay-bin-11.0.2-1-x86_64.pkg.tar.zst: Zstandard compressed data (v0.8+), Dictionary ID: None</span><br><span class="line">[lsjarch@LsjsArch ~]$ file Downloads/</span><br><span class="line">Downloads/: directory</span><br></pre></td></tr></table></figure>
<p>虽然Linux不要求扩展名来表示文件类型，但我们期望一些合理的命名方式来体现其文件类型。在Linux（及其他类Unix系统）中，一切皆文件。</p>
<h3 id="3-5浏览文件内容">3.5	浏览文件内容</h3>
<p><strong>什么是“文本”？</strong></p>
<ul>
<li>在信息与数字之间建立联系，则可以用数字来表示信息。如ASCII码；</li>
<li>文本是简单的字符与数字之间的一对一映射，非常紧凑，对某数量的字符文本常常会翻译成不少于该数量的数字数据（因为在某些复杂的编码中，会有很多非文本元素来描述文本的结构和格式，即控制字）</li>
<li>许多系统的配置文件是以文本格式存储的，阅读他们可以深入了解系统的工作方式。许多脚本文件也是如此。</li>
</ul>
<p><code>less</code>：用来浏览文本文件；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看定义了系统中全部用户身份的文件</span></span><br><span class="line">[lsjarch@LsjsArch ~]$ ls /etc/passwd</span><br><span class="line">/etc/passwd</span><br><span class="line">[lsjarch@LsjsArch ~]$ less /etc/passwd</span><br></pre></td></tr></table></figure>
<p><em><code>less</code>程序中常用的键盘命令：</em></p>
<ul>
<li><code>Page UP</code> or <code>b</code>：					向上翻滚一页</li>
<li><code>Page Down</code> or <code>space</code>：      	向下翻滚一页</li>
<li><code>UP Arrow</code>：                           向上翻滚一行</li>
<li><code>Down Arrow</code>：                        向下翻滚一行</li>
<li><code>G</code>：                                      移动到最后一行</li>
<li><code>1G</code> or <code>g</code>：                           移动到开头一行</li>
<li><code>/characters</code>：                      向前查找指定字符串</li>
<li><code>n</code>：                                      向前查找下一个出现的字符串，这个字符串是之前所指定查找的</li>
<li><code>q</code>：                                      退出</li>
<li><code>h</code>：                                      显示帮助屏幕</li>
</ul>
<p>*<code>less</code>历史：*less是早期Unix程序more的改进版，“less is more”开了个玩笑</p>
<p><em><code>less</code>属于<code>页面调度器</code>程序类</em>，这些程序允许通过页方式，在一页中轻松地浏览长文本文档。<code>more</code>程序只能向前分页浏览，<code>less</code>则允许前后分页浏览等新特性；</p>
<h3 id="3-6开始探索Linux吧！">3.6	开始探索Linux吧！</h3>
<p>通过上面学习到的四个命令<code>cd</code>、<code>ls -l</code>、<code>file</code>、<code>less</code>，即可开始在Linux文件系统中游览。</p>
<p>不要害怕沾花惹草，普通用户没有权限搞乱系统，那是管理员的工作。在Linux系统中，没有秘密。</p>
<table>
<thead>
<tr>
<th style="text-align:center">目录</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/</td>
<td>根目录，万物起源</td>
</tr>
<tr>
<td style="text-align:center">/bin</td>
<td>包含系统启动和运行所必需的二进制程序</td>
</tr>
<tr>
<td style="text-align:center">/boot</td>
<td>包含Linux内核，最初的RMA磁盘映像(系统启动时由驱动程序所需)，和启动加载程序。</td>
</tr>
<tr>
<td style="text-align:center">/dev</td>
<td>包含设备结点的特殊目录。“一切皆文件”的观点也适用于设备，这个目录中内核维护着它支持的设备</td>
</tr>
<tr>
<td style="text-align:center">/etc</td>
<td>包含所有系统层面的配置文件，也包含一系列shell脚本，用于系统启动时运行每个系统服务。这个目录中应该全是可读文本文件</td>
</tr>
<tr>
<td style="text-align:center">/home</td>
<td>通常，系统会为每个用户在/home目录下分配一个目录。普通用户只能在自己的目录下写入文件，避免了错误的用户活动破坏系统</td>
</tr>
<tr>
<td style="text-align:center">/lib</td>
<td>包含核心系统程序所需的库文件</td>
</tr>
<tr>
<td style="text-align:center">/lost + found</td>
<td>每个使用Linux文件系统的格式化分区或设备，都会有这个目录。当部分恢复一个损坏的文件系统时，会用到这个目录，除非文件系统完全损坏，这个目录会是个空目录。</td>
</tr>
<tr>
<td style="text-align:center">/media</td>
<td>现代Linux中，/media包含可移除媒体设备(USB驱动器、CD-ROMs等)的挂载点，这些设备连接到计算机后，会自动地挂载到这个目录结点下</td>
</tr>
<tr>
<td style="text-align:center">/mnt</td>
<td>早期Linux中，/mnt包含可移除设备的的挂载点</td>
</tr>
<tr>
<td style="text-align:center">/opt</td>
<td>用来安装“可选的”软件，存储可能安装在系统中的商业软件产品</td>
</tr>
<tr>
<td style="text-align:center">/proc</td>
<td>从存储在硬盘上的文件的意义上说，它不是真正的文件系统，而是一个由Linux内核维护的虚拟文件系统，包含内核的窥视孔文件。这些文件是可读的，它们会表明内核是怎样监管计算机的</td>
</tr>
<tr>
<td style="text-align:center">/root</td>
<td>root账户的家目录</td>
</tr>
<tr>
<td style="text-align:center">/sbin</td>
<td>包含“系统”二进制文件，是完成重大系统任务的程序，通常为超级用户保留</td>
</tr>
<tr>
<td style="text-align:center">/tmp</td>
<td>用来存储由各种程序创建的临时文件。一些配置会让系统每次重启时都清空这个目录</td>
</tr>
<tr>
<td style="text-align:center">/usr</td>
<td>包含普通用户所需要的所有程序和文件，可能是最大的一个目录</td>
</tr>
<tr>
<td style="text-align:center">/usr/bin</td>
<td>包含系统安装的可执行程序</td>
</tr>
<tr>
<td style="text-align:center">/usr/lib</td>
<td>包含/usr/bin目录中的程序所用的共享库</td>
</tr>
<tr>
<td style="text-align:center">/usr/local</td>
<td>是非系统发行版自带而打算让系统使用的程序的安装目录。通常，由源码编译的程序会安装在/usr/local/bin目录下</td>
</tr>
<tr>
<td style="text-align:center">/usr/sbin</td>
<td>包含许多系统管理程序</td>
</tr>
<tr>
<td style="text-align:center">/usr/share</td>
<td>包含许多由/usr/bin目录中的程序使用的共享数据。包括默认的配置文件，图标，桌面背景，音频文件等</td>
</tr>
<tr>
<td style="text-align:center">/usr/share/doc</td>
<td>存放按照软件包分类的文档</td>
</tr>
<tr>
<td style="text-align:center">/var</td>
<td>除/tmp、/home外，之上的目录是静态的。而/var目录存储可能需要改动的文件，各种数据库、假脱机文件、用户邮件等都在这里</td>
</tr>
<tr>
<td style="text-align:center">/var/log</td>
<td>包含日志文件，各种系统活动的记录。这些文件十分重要，并应时时监测，最重要的是/var/log/messages。查看日志文件可能需要超级用户权限</td>
</tr>
</tbody>
</table>
<p><em>一些常用文件：</em></p>
<ul>
<li><code>/boot/grub/grub.conf</code> or <code>menu.lst</code>：  用来配置启动加载程序</li>
<li><code>/boot/vmlinuz</code>：                                 Linux内核</li>
<li><code>/etc/crontav</code>：                                  定义自动运行的任务</li>
<li><code>/etc/fstab</code>：                                     包含存储设备的列表，以及与他们相关的挂载点</li>
<li><code>/etc/passwd</code>：                                    包含用户帐号列表</li>
</ul>
<h3 id="3-7符号链接">3.7	符号链接</h3>
<p>符号链接，又称软链接或<code>symlink</code>，表示一个文件被多个文件名指向，而这个特殊文件在<code>ls -l</code>命令中的标识不是“<code>-</code>”或“<code>d</code>”，而是“<code>l</code>”。</p>
<p>*存在意义：*如果一个文件会经常更新以导致有不同的版本号，而有许多程序需要使用这个文件，那么在更改版本后需要跟踪每个使用该文件资源的程序进行修改，这非常低效。而如果指定创建一个公用符号链接，程序使用这个符号链接，而在每次更新版本后都只需修改符号链接的指向即可。</p>
<h3 id="3-8拓展阅读">3.8	拓展阅读</h3>
<ul>
<li>完整的Linux文件系统层次体系标准：<a target="_blank" rel="noopener" href="https://www.pathname.com/fhs">https://www.pathname.com/fhs</a></li>
</ul>
<hr>
<h2 id="四、操作文件和目录">四、操作文件和目录</h2>
<p>本章命令：<code>cp</code>, <code>mv</code>, <code>mkdir</code>, <code>rm</code>, <code>ln</code>。</p>
<h3 id="4-1通配符">4.1	通配符</h3>
<p>通配符用来快速指定一组文件名。使用通配符允许依据字符类型来选择文件名；</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>匹配任意多个字符（包括0个或1个）</td>
</tr>
<tr>
<td>?</td>
<td>匹配任意一个字符（不包括0个）</td>
</tr>
<tr>
<td>[characters]</td>
<td>匹配任意一个属于字符集中的字符</td>
</tr>
<tr>
<td>[!characters]</td>
<td>匹配任意一个不是字符集中的字符</td>
</tr>
<tr>
<td>[[:class:]]</td>
<td>匹配任意一个属于指定字符类中的字符</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>常用字符类</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>[:alnum:]</td>
<td>匹配任意一个字母或数字</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>匹配任意一个字母</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>匹配任意一个数字</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>匹配任意一个小写字母</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>匹配任意一个大写字母</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>类型匹配的模式</th>
<th>匹配对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>所有文件</td>
</tr>
<tr>
<td>g*</td>
<td>文件名以g开头的所有文件</td>
</tr>
<tr>
<td>b*.txt</td>
<td>以b开头而以.txt结尾的任意多字符的文件</td>
</tr>
<tr>
<td>Data???</td>
<td>以Data开头紧接三个字符的文件</td>
</tr>
<tr>
<td>[abc]*</td>
<td>以a或b或c开头的文件</td>
</tr>
<tr>
<td>BACKUP.[0-9][0-9][0-9]</td>
<td>以BACKUP.开头并紧接3个数字的文件</td>
</tr>
<tr>
<td>[[:upper:]]*</td>
<td>以大写字母开头的文件</td>
</tr>
<tr>
<td>[![:digit:]]*</td>
<td>不以数字开头的文件</td>
</tr>
<tr>
<td>*[[:lower:]123]</td>
<td>文件名以小写字母结尾，或以1或2或3结尾的文件</td>
</tr>
</tbody>
</table>
<p>事实上，接受参数为文件名的所有命令，都可以使用通配符。</p>
<p>在现代Linux中，尽量避免使用[A-Z]或[a-z]的方式表示字符范围，因为不会产生所期望的结果，要用字符类代替。</p>
<p>通配符在GUI界面也是有效的，以KDE桌面为例，在<code>Dolphin</code>和<code>Konqueror</code>的地址栏中直接输入通配符，文件管理器会显示匹配的结果。</p>
<h3 id="4-2创建目录">4.2	创建目录</h3>
<p><code>mkdir</code>：用来创建目录；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ cd Documents/</span><br><span class="line">[lsjarch@LsjsArch Documents]$ mkdir test_cmd</span><br><span class="line">[lsjarch@LsjsArch Documents]$ ls</span><br><span class="line">helloworld.txt  test_cmd</span><br><span class="line">[lsjarch@LsjsArch Documents]$ cd test_cmd/</span><br><span class="line">[lsjarch@LsjsArch test_cmd]$ mkdir mkdir1 mkdir2 mkdir3</span><br><span class="line">[lsjarch@LsjsArch test_cmd]$ ls</span><br><span class="line">mkdir1  mkdir2  mkdir3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可见，mkdir可以跟多个参数以创建多个目录，只需空格分隔。</p>
<h3 id="4-3复制文件和目录">4.3	复制文件和目录</h3>
<p><code>cp</code>：复制文件和目录；</p>
<p>一些可用的选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_cmd]$ cp --help</span><br><span class="line">用法：cp [选项]... [-T] 源文件 目标文件</span><br><span class="line">　或：cp [选项]... 源文件... 目录</span><br><span class="line">　或：cp [选项]... -t 目录 源文件...</span><br><span class="line">将指定&lt;源文件&gt;复制至&lt;目标文件&gt;，或将多个&lt;源文件&gt;复制至&lt;目标目录&gt;。</span><br><span class="line"></span><br><span class="line">必选参数对长短选项同时适用。</span><br><span class="line">  -a, --archive                 等于-dR --preserve=all，复制文件和目录，以及她们的属性，包括所有权和权限。通常复本具有用户所操作文件的默认属性</span><br><span class="line">      --attributes-only 仅复制属性而不复制数据      --backup[=CONTROL           为每个已存在的目标文件创建备份</span><br><span class="line">  -b                            类似--backup 但不接受参数</span><br><span class="line">      --copy-contents           在递归处理是复制特殊文件内容</span><br><span class="line">  -d                            等于--no-dereference --preserve=links</span><br><span class="line">  -f, --force                   如果有已存在的目标文件且无法打开，则将其删除并重试（该选项在与 -n 选项同时使用时将被忽略）</span><br><span class="line">  -i, --interactive             覆盖前询问（使前面的 -n 选项失效）。在重写已存在文件之前，提示用户确认，如不指定则会默认重写文件</span><br><span class="line">  -H                            跟随源文件中的命令行符号链接</span><br><span class="line">  -l, --link                    硬链接文件以代替复制</span><br><span class="line">  -L, --dereference             总是跟随源文件中的符号链接</span><br><span class="line">  -n, --no-clobber              不要覆盖已存在的文件(使前面的 -i 选项失效)</span><br><span class="line">  -P, --no-dereference          不跟随源文件中的符号链接</span><br><span class="line">  -p                            等于--preserve=模式,所有权,时间戳</span><br><span class="line">      --preserve[=属性列表      保持指定的属性(默认：模式,所有权,时间戳)，如果可能保持附加属性：上下文、链接、xattr 等</span><br><span class="line">      --sno-preserve=属性列表   不保留指定的文件属性</span><br><span class="line">      --parents                 复制前在目标目录创建来源文件路径中的所有目录</span><br><span class="line">  -R, -r, --recursive           递归复制目录及其子目录内的所有内容。复制目录时，需要使用这个选项</span><br><span class="line">      --reflink[=WHEN]          控制克隆/CoW 副本。请查看下面的内如。</span><br><span class="line">      --remove-destination      尝试打开目标文件前先删除已存在的目的地文件 (相对于 --force 选项)</span><br><span class="line">      --sparse=WHEN             控制创建稀疏文件的方式</span><br><span class="line">      --strip-trailing-slashes  删除参数中所有源文件/目录末端的斜杠</span><br><span class="line">  -s, --symbolic-link           只创建符号链接而不复制文件</span><br><span class="line">  -S, --suffix=后缀             自行指定备份文件的后缀</span><br><span class="line">  -t,  --target-directory=目录  将所有参数指定的源文件/目录复制至目标目录</span><br><span class="line">  -T, --no-target-directory     将目标目录视作普通文件</span><br><span class="line">  -u, --update                  只在源文件比目标文件新，或目标文件不存在时才进行复制</span><br><span class="line">  -v, --verbose                 显示详细的进行步骤</span><br><span class="line">  -x, --one-file-system 	   不跨越文件系统进行操作</span><br><span class="line">  -Z                            设置目标文件的 SELinux 安全上下文为默认类型</span><br><span class="line">      --context[=上下文]        类似 -Z；如果指定了上下文，则将 SELinux 或SMACK 安全上下文设置为指定值</span><br><span class="line">      --help                    显示此帮助信息并退出</span><br><span class="line">      --version                 显示版本信息并退出</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一些<code>cp</code>实例：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>运行结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>cp file1 file2</td>
<td>复制文件file1内容到file2文件。如果file2已存在则会被file1的内容重写，如不存在则会创建file2</td>
</tr>
<tr>
<td>cp -i file1 file2</td>
<td>作用与上一条一样，只有在file2存在进行重写时，会提示用户确认信息</td>
</tr>
<tr>
<td>cp file1 file2 dir1</td>
<td>复制文件file1和file2到目录dir1。dir1必须存在</td>
</tr>
<tr>
<td>cp dir1/* dir2</td>
<td>使用一个通配符，将目录dir1中所有文件都复制到目录dir2中，dir2必须存在</td>
</tr>
<tr>
<td>cp -r dir1 dir2</td>
<td>递归复制dir1中的所有内容到dir2中。如果目录dir2不存在，则会创建，如果存在则直接复制</td>
</tr>
</tbody>
</table>
<h3 id="4-4移动和重命名文件">4.4	移动和重命名文件</h3>
<p><code>mv</code>：可以实现文件移动和重命名，但不论如何完成操作后原文件名都不再存在；</p>
<p>一些可用的选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_cmd]$ mv --help</span><br><span class="line">用法：mv [选项]... [-T] 源文件 目标文件</span><br><span class="line">　或：mv [选项]... 源文件... 目录</span><br><span class="line">　或：mv [选项]... -t 目录 源文件...</span><br><span class="line">将&lt;源文件&gt;重命名为&lt;目标文件&gt;，或将&lt;源文件&gt;移动至指定&lt;目录&gt;。</span><br><span class="line"></span><br><span class="line">必选参数对长短选项同时适用。</span><br><span class="line">      --backup[=CONTROL]       为每个已存在的目标文件创建备份</span><br><span class="line">  -b                           类似--backup 但不接受参数</span><br><span class="line">  -f, --force                  覆盖前不询问</span><br><span class="line">  -i, --interactive            覆盖前询问</span><br><span class="line">  -n, --no-clobber             不覆盖已存在文件。如果您指定了-i、-f、-n 中的多个，仅最后一个生效。</span><br><span class="line">      --strip-trailing-slashes  去掉每个源文件参数尾部的斜线</span><br><span class="line">  -S, --suffix=SUFFIX          替换常用的备份文件后缀</span><br><span class="line">  -t, --target-directory=目录  将所有&lt;源文件&gt;移动至指定的&lt;目录&gt;中</span><br><span class="line">  -T, --no-target-directory    将参数中所有&lt;目标文件&gt;部分视为普通文件</span><br><span class="line">  -u, --update                 仅在&lt;源文件&gt;比目标文件更新，或者目标文件不存在时进行移动操作</span><br><span class="line">  -v, --verbose                对正在发生的操作给出解释</span><br><span class="line">  -Z, --context                将目标文件的 SELinux 安全上下文设置为默认类型</span><br><span class="line">      --help                   显示此帮助信息并退出</span><br><span class="line">      --version                显示版本信息并退出</span><br></pre></td></tr></table></figure>
<p>一些<code>mv</code>实例：</p>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:left">运行结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">mv file1 file2</td>
<td style="text-align:left">移动file1到file2。如果file2存在，则其内容被file1的内容重写，如不存在则创建file2</td>
</tr>
<tr>
<td style="text-align:center">mv -i file1 file2</td>
<td style="text-align:left">作用与上一条一样，除了file2存在并且被file1的内容重写前，会向用户提示信息</td>
</tr>
<tr>
<td style="text-align:center">mv  file1 file2 dir1</td>
<td style="text-align:left">移动file1和file2到dir1中，前提是dir1必须存在</td>
</tr>
<tr>
<td style="text-align:center">mv dir1 dir2</td>
<td style="text-align:left">如果dir2不存在，则创建dir2目录并移动dir1中内容到目录dir2中，同时删除dir1；如果dir2已存在，则直接移动dir1内容并删除原dir1</td>
</tr>
</tbody>
</table>
<h3 id="4-5删除文件和目录">4.5	删除文件和目录</h3>
<p><code>rm</code>：用来移除文件和目录；</p>
<p>一些可用的选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_cmd]$ rm --help</span><br><span class="line">用法：rm [选项]... [文件]...</span><br><span class="line">删除（unlink）指定&lt;文件&gt;。</span><br><span class="line"></span><br><span class="line">  -f, --force               强制删除。忽略不存在的文件，不提示确认</span><br><span class="line">  -i                        每次删除前提示确认。如不指定，则`rm`会默默地删除文件</span><br><span class="line">  -I                        在删除超过三个文件或者递归删除前提示一次并要求确认；此选项比 -i 提示内容更少，但同样可以阻止大多数错误发生</span><br><span class="line">      --interactive[=场景]  根据指定的&lt;场景&gt;进行确认提示：never（从不）、once（一次，等效于使用 -I）或者 always（总是，等效于使用 -i）。如果使用此参数                             没有指定&lt;场景&gt;则总是提示</span><br><span class="line">      --one-file-system     递归删除一个层级时，跳过所有不符合命令行参数的文件系统上的文件</span><br><span class="line">      --no-preserve-root    不要对“/”特殊处理</span><br><span class="line">      --preserve-root[=all] 不要删除“/”（默认行为）；如添加了“all”参数，将拒绝处理与父目录位于不同设备上的命令行参数</span><br><span class="line">  -r, -R, --recursive       递归删除目录及其内容</span><br><span class="line">  -d, --dir                 删除空目录</span><br><span class="line">  -v, --verbose             详细显示进行的步骤</span><br><span class="line">      --help                显示此帮助信息并退出</span><br><span class="line">      --version             显示版本信息并退出</span><br><span class="line"></span><br><span class="line">默认时，rm 不会删除目录。使用--recursive(-r 或-R)选项可删除每个给定的目录，以及其下所有的内容。</span><br><span class="line"></span><br><span class="line">要删除文件名第一个字符为“-”的文件（例如“-foo”），请使用以下方法之一：</span><br><span class="line">  rm -- -foo</span><br><span class="line">  rm ./-foo</span><br><span class="line"></span><br><span class="line">请注意，如果使用 rm 来删除文件，在有充足的经验和时间的情况下通常仍可能将该文件的内容恢复出来。如果想进一步保证所删除的文件的内容无法还原，请考虑使用 shred(1)。</span><br></pre></td></tr></table></figure>
<p>一些<code>rm</code>实例：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>运行结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>rm file1</td>
<td>默默地删除文件</td>
</tr>
<tr>
<td>rm -i file1</td>
<td>除了在删除文件之前，提示用户确认信息外，和上面的命令作用一样</td>
</tr>
<tr>
<td>rm -r file1 dir1</td>
<td>删除文件file1，目录dir1，及dir1中的内容</td>
</tr>
<tr>
<td>rm -rf file1 dir1</td>
<td>同上，除了当file1或dir1不存在时命令仍会执行</td>
</tr>
</tbody>
</table>
<p><em><strong>小心！</strong></em></p>
<ul>
<li>Linux（及类Unix系统）没有复原命令；</li>
<li>尤其小心通配符<code>*</code>。养成良好的习惯，无论什么时候使用通配符在<code>rm</code>命令中，都要用<code>ls</code>命令来测试通配符的结果，然后再调用历史命令并仅用<code>rm</code>替换<code>ls</code>重新执行。</li>
</ul>
<h3 id="4-6创建链接">4.6	创建链接</h3>
<p><code>ln</code>：创建硬链接或符号链接；</p>
<ul>
<li>
<p>硬链接</p>
<ul>
<li>
<p><code>ln file link</code></p>
</li>
<li>
<p>相较符号链接而言，硬链接更古老。</p>
</li>
<li>
<p>默认情况下，每个文件有一个硬链接，这个硬链接给文件起名字，当创建一个硬链接后，就为文件创建了一个额外的目录条目</p>
</li>
<li>
<p>两个局限：</p>
<ul>
<li>
<p>一个硬链接不能关联它所在文件系统之外的文件。即一个链接不能关联与链接本身不在同一个磁盘分区上的文件；</p>
</li>
<li>
<p>一个硬链接不能关联一个目录。</p>
<p>一个硬链接与文件本身并没有什么区别，当列出一个包含硬链接的目录内容时，并没有特殊的链接指示说明。当一个硬链接被删除时，文件本身内容仍存在，直到所有关联这个文件的链接都被删除。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>符号链接</p>
<ul>
<li><code>ln -s item link</code></li>
<li>符号链接生效，是通过创建一个特殊类型的文件，这个文件包含一个关联文件或目录的文本指针，从这个意义上将与Windows的快捷方式类似。</li>
<li>特点：
<ul>
<li>一个符号链接指向一个文件，而且这个符号链接本身与其它的符号链接没有什么区别。如果向一个符号链接里面写入东西，那么相关联的文件也被写入；</li>
<li>当删除一个符号链接时，只有符号链接本身被删除，而指向的文件不会受影响；</li>
<li>如果先于符号链接删除文件，链接不会消失但不会指向任何东西，此时称为<code>坏链接</code>。<code>ls</code>命令中常以红色标识坏链接的存在。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>一些可用的选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_operafile]$ ln -s --help</span><br><span class="line">用法：ln [选项]... [-T] 目标 链接名</span><br><span class="line">　或：ln [选项]... 目标</span><br><span class="line">　或：ln [选项]... 目标... 目录</span><br><span class="line">　或：ln [选项]... -t 目录 目标...</span><br><span class="line">在第一种格式中，创建具有指定链接名且指向指定目标的链接。</span><br><span class="line">在第二种格式中，在当前目录创建指向目标位置的链接。</span><br><span class="line">在第三、四种格式中，在指定目录中创建指向指定目标的链接。</span><br><span class="line">默认创建硬链接，当使用--symbolic 时创建符号链接。</span><br><span class="line">默认情况下，创建每个目标时不应存在与新链接的名称相同的文件。</span><br><span class="line">创建硬链接时，每个指定的目标都必须存在。符号链接可以指向任意的位置；</span><br><span class="line">当链接解析正常时，将其解析为一个相对于其父目录的相对链接。</span><br><span class="line"></span><br><span class="line">必选参数对长短选项同时适用。</span><br><span class="line">      --backup[=CONTROL]      为每个已存在的目标文件创建备份文件</span><br><span class="line">  -b                          类似--backup，但不接受任何参数</span><br><span class="line">  -d, -F, --directory         允许超级用户尝试创建指向目录的硬链接（注意：此操作可能因系统限制而失败）</span><br><span class="line">  -f, --force                 强行删除任何已存在的目标文件</span><br><span class="line">  -i, --interactive           prompt whether to remove destinations</span><br><span class="line">  -L, --logical               dereference TARGETs that are symbolic links</span><br><span class="line">  -n, --no-dereference        treat LINK_NAME as a normal file if it is a symbolic link to a directory</span><br><span class="line">  -P, --physical              make hard links directly to symbolic links</span><br><span class="line">  -r, --relative              with -s, create links relative to link location</span><br><span class="line">  -s, --symbolic              make symbolic links instead of hard links</span><br><span class="line">  -S, --suffix=后缀           自行指定备份文件的后缀</span><br><span class="line">  -t, --target-directory=目录  在指定的目录中创建链接</span><br><span class="line">  -T, --no-target-directory   总是将给定的链接名当作普通文件</span><br><span class="line">  -v, --verbose               列出每个链接的文件名称</span><br><span class="line">      --help                  显示此帮助信息并退出</span><br><span class="line">      --version               显示版本信息并退出</span><br><span class="line"></span><br><span class="line">备份文件的后缀为&quot;~&quot;，除非以--suffix 选项或是 SIMPLE_BACKUP_SUFFIX环境变量指定。版本控制的方式可通过--backup 选项或 VERSION_CONTROL 环境</span><br><span class="line">变量来选择。以下是可用的变量值：</span><br><span class="line"></span><br><span class="line">  none, off       不进行备份(即使使用了--backup 选项)</span><br><span class="line">  numbered, t     备份文件加上数字进行排序</span><br><span class="line">  existing, nil   若有数字的备份文件已经存在则使用数字，否则使用普通方式备份</span><br><span class="line">  simple, never   永远使用普通方式备份</span><br><span class="line"></span><br><span class="line">使用 -s 选项会忽略 -L 和 -P。否则当给定的目标为一个符号链接（默认为 -P）时，会由最后一个指定的选项来控制行为。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-7练习一下">4.7	练习一下</h3>
<ol>
<li>
<p>在家目录下创建一个<code>test_operafile</code>目录；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ cd</span><br><span class="line">[lsjarch@LsjsArch ~]$ mkdir test_operafile</span><br><span class="line">[lsjarch@LsjsArch ~]$ ls</span><br><span class="line">Desktop  Documents  Downloads  Music  Pictures  Postman  Public  Templates  test_operafile  Videos</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在<code>test_operafile</code>目录下创建两个目录<code>dir1</code>和<code>dir2</code>；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ mkdir test_operafile/dir1 test_operafile/dir2</span><br><span class="line">[lsjarch@LsjsArch ~]$ ls test_operafile/</span><br><span class="line">dir1  dir2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>复制<code>/etc/passwd</code>文件到<code>test_operafile</code>目录下；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ cp /etc/passwd test_operafile/</span><br><span class="line">[lsjarch@LsjsArch ~]$ cd test_operafile/</span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ ls -l</span><br><span class="line">总用量 12</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch 4096  1月  2 21:11 dir1</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch 4096  1月  2 21:11 dir2</span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch 1231  1月  2 21:14 passwd</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 尝试一下另两个选项</span></span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ cp -v -i /etc/passwd .</span><br><span class="line">cp：是否覆盖&#x27;./passwd&#x27;？ yes</span><br><span class="line">&#x27;/etc/passwd&#x27; -&gt; &#x27;./passwd&#x27;</span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ ls -l</span><br><span class="line">总用量 12</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch 4096  1月  2 21:11 dir1</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch 4096  1月  2 21:11 dir2</span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch 1231  1月  2 21:19 passwd</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>移动和重命名文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先将 passwd 文件改名为 test1</span></span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ mv passwd test1</span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ ls</span><br><span class="line">dir1  dir2  test1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 test1 文件先后移动到 dir1 和 dir2 ，最后移回 test_operafile 的根目录</span></span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ mv test1 dir1</span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ ls . dir1</span><br><span class="line">.:</span><br><span class="line">dir1  dir2</span><br><span class="line"></span><br><span class="line">dir1:</span><br><span class="line">test1</span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ mv dir1/test1 dir2</span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ ls -l dir1 dir2</span><br><span class="line">dir1:</span><br><span class="line">总用量 0</span><br><span class="line"></span><br><span class="line">dir2:</span><br><span class="line">总用量 4</span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch 1231  1月  2 21:19 test1</span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ mv dir2/test1 .</span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ ls dir2 .</span><br><span class="line">.:</span><br><span class="line">dir1  dir2  test1</span><br><span class="line"></span><br><span class="line">dir2:</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果将 test1 移动到此时并不存在的 dir3 呢？</span></span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ mv test1 dir3</span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ ls . dir3</span><br><span class="line">dir3</span><br><span class="line"></span><br><span class="line">.:</span><br><span class="line">dir1  dir2  dir3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以看到，不存在目录dir3时，会将 test1 改名为 dir3 ，并不改变路径</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建硬链接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_operafile]$ mv dir3 test1</span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ ls</span><br><span class="line">dir1  dir2  test1</span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ ln test1 test1-hard</span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ ln test1 dir1/test1-hard2</span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ ln test1 dir2/test1-hard3</span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ ls -l </span><br><span class="line">总用量 16</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch 4096  1月  2 21:59 dir1</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch 4096  1月  2 21:59 dir2</span><br><span class="line">-rw-r--r-- 4 lsjarch lsjarch 1231  1月  2 21:19 test1</span><br><span class="line">-rw-r--r-- 4 lsjarch lsjarch 1231  1月  2 21:19 test1-hard</span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ ls -l dir1/ dir2/</span><br><span class="line">dir1/:</span><br><span class="line">总用量 4</span><br><span class="line">-rw-r--r-- 4 lsjarch lsjarch 1231  1月  2 21:19 test1-hard2</span><br><span class="line"></span><br><span class="line">dir2/:</span><br><span class="line">总用量 4</span><br><span class="line">-rw-r--r-- 4 lsjarch lsjarch 1231  1月  2 21:19 test1-hard3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意到，硬链接的第二个字段都是4，这表示文件 test1 的硬链接数目。一个文件至少有一个硬链接，因为文件名就是由链接创建的。</p>
<p>如何验证 test1 和 test1-hard 是同一文件呢？我们先假定硬链接问题中，文件由两部分组成——文件内容的数据部分和持有文件名的名字部分，当创建文件硬链接时，实际上是为文件创建了额外的名字部分，并且这些名字都关联到相同的数据部分。</p>
<p>这时，系统会分配一连串的磁盘给所谓的索引节点，然后索引节点与文件名字部分相关联，因此每一个硬链接都关系到一个具体的包含文件内容的索引节点。通过<code>ls -i</code>命令来展示文件索引节点的信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_operafile]$ ls -li . dir1/test1-hard2 dir2/test1-hard3 </span><br><span class="line">788507 -rw-r--r-- 4 lsjarch lsjarch 1231  1月  2 21:19 dir1/test1-hard2</span><br><span class="line">788507 -rw-r--r-- 4 lsjarch lsjarch 1231  1月  2 21:19 dir2/test1-hard3</span><br><span class="line"></span><br><span class="line">.:</span><br><span class="line">总用量 16</span><br><span class="line">788502 drwxr-xr-x 2 lsjarch lsjarch 4096  1月  2 21:59 dir1</span><br><span class="line">788506 drwxr-xr-x 2 lsjarch lsjarch 4096  1月  2 21:59 dir2</span><br><span class="line">788507 -rw-r--r-- 4 lsjarch lsjarch 1231  1月  2 21:19 test1</span><br><span class="line">788507 -rw-r--r-- 4 lsjarch lsjarch 1231  1月  2 21:19 test1-hard</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第一个字段表示的即是文件索引节点号，由此证实， test1 和 test1-hard 是同一文件。</p>
</li>
<li>
<p>创建符号链接</p>
<p>建立符号链接是为了解决硬链接的两个缺点——不能跨物理设备和不能关联目录。符号链接是文件的特殊类型，包含一个指向目标文件或目录的文本指针。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_operafile]$ ls</span><br><span class="line">dir1  dir2  test1  test1-hard</span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ ln -s test1 test1-sym</span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ ls</span><br><span class="line">dir1  dir2  test1  test1-hard  test1-sym</span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ ls -li</span><br><span class="line">总用量 16</span><br><span class="line">788502 drwxr-xr-x 2 lsjarch lsjarch 4096  1月  2 23:47 dir1</span><br><span class="line">788506 drwxr-xr-x 2 lsjarch lsjarch 4096  1月  2 23:49 dir2</span><br><span class="line">788507 -rw-r--r-- 4 lsjarch lsjarch 1231  1月  2 21:19 test1</span><br><span class="line">788507 -rw-r--r-- 4 lsjarch lsjarch 1231  1月  2 21:19 test1-hard</span><br><span class="line">788508 lrwxrwxrwx 1 lsjarch lsjarch    5  1月  2 23:41 test1-sym -&gt; test1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以看到，在当前目录创建了名为 test1-sym 的符号链接指向 test1 文件，且符号链接是一个特殊的文件，其索引节点号与 test1 文件不同</span></span><br><span class="line"></span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ ln -s ../test1 dir1/test1-sym2</span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ ls -li dir1 .</span><br><span class="line">.:</span><br><span class="line">总用量 16</span><br><span class="line">788502 drwxr-xr-x 2 lsjarch lsjarch 4096  1月  2 23:47 dir1</span><br><span class="line">788506 drwxr-xr-x 2 lsjarch lsjarch 4096  1月  2 23:49 dir2</span><br><span class="line">788507 -rw-r--r-- 4 lsjarch lsjarch 1231  1月  2 21:19 test1</span><br><span class="line">788507 -rw-r--r-- 4 lsjarch lsjarch 1231  1月  2 21:19 test1-hard</span><br><span class="line">788508 lrwxrwxrwx 1 lsjarch lsjarch    5  1月  2 23:41 test1-sym -&gt; test1</span><br><span class="line"></span><br><span class="line">dir1:</span><br><span class="line">总用量 4</span><br><span class="line">788507 -rw-r--r-- 4 lsjarch lsjarch 1231  1月  2 21:19 test1-hard2</span><br><span class="line">788509 lrwxrwxrwx 1 lsjarch lsjarch    8  1月  2 23:47 test1-sym2 -&gt; ../test1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以看到，创建一个符号链接的时候，会建立一个目标文件在哪里和符号链接有关联的文本描述：相对于test1-sym2的存储位置，test1在它的父目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同时，符号链接文件的长度为8，这是 ../test1 字符串的长度，而不是符号链接所指向的文件长度</span></span><br><span class="line"></span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ ln -s test1 dir2/test-sym3</span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ ls -li . dir2</span><br><span class="line">.:</span><br><span class="line">总用量 16</span><br><span class="line">788502 drwxr-xr-x 2 lsjarch lsjarch 4096  1月  2 23:47 dir1</span><br><span class="line">788506 drwxr-xr-x 2 lsjarch lsjarch 4096  1月  2 23:49 dir2</span><br><span class="line">788507 -rw-r--r-- 4 lsjarch lsjarch 1231  1月  2 21:19 test1</span><br><span class="line">788507 -rw-r--r-- 4 lsjarch lsjarch 1231  1月  2 21:19 test1-hard</span><br><span class="line">788508 lrwxrwxrwx 1 lsjarch lsjarch    5  1月  2 23:41 test1-sym -&gt; test1</span><br><span class="line"></span><br><span class="line">dir2:</span><br><span class="line">总用量 4</span><br><span class="line">788507 -rw-r--r-- 4 lsjarch lsjarch 1231  1月  2 21:19 test1-hard3</span><br><span class="line">788510 lrwxrwxrwx 1 lsjarch lsjarch    5  1月  2 23:49 test-sym3 -&gt; test1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意到，这个命令在指定目标文件 test1 时并没有标注其相对路径，而导致所建立的符号链接对目标文件路径的描述有误</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证：</span></span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ less dir2/test1-sym3</span><br><span class="line">dir2/test1-sym3: 没有那个文件或目录</span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ less dir1/test1-sym2 # 可以正常打开，文件内容此处省略</span><br><span class="line"><span class="meta">#</span><span class="bash"> 由此，要理解 ln 名令中所指向的目标文件的路径是相对于符号链接文件而言，否则会出现指向错误</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当然，如果使用绝对路径表示指向文件，不会出现问题。但更倾向于使用相对路径名，因为它允许一个包含符号链接的目录重命名或移动，而不破坏链接</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>移动文件和目录</p>
<p>首先，利用<code>rm</code>命令删除一个硬链接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_operafile]$ ls -l</span><br><span class="line">总用量 16</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch 4096  1月  2 23:47 dir1</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch 4096  1月  2 23:49 dir2</span><br><span class="line">-rw-r--r-- 4 lsjarch lsjarch 1231  1月  2 21:19 test1</span><br><span class="line">-rw-r--r-- 4 lsjarch lsjarch 1231  1月  2 21:19 test1-hard</span><br><span class="line">lrwxrwxrwx 1 lsjarch lsjarch    5  1月  2 23:41 test1-sym -&gt; test1</span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ rm -v test1-hard </span><br><span class="line">已删除 &#x27;test1-hard&#x27;</span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ ls -l</span><br><span class="line">总用量 12</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch 4096  1月  2 23:47 dir1</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch 4096  1月  2 23:49 dir2</span><br><span class="line">-rw-r--r-- 3 lsjarch lsjarch 1231  1月  2 21:19 test1</span><br><span class="line">lrwxrwxrwx 1 lsjarch lsjarch    5  1月  2 23:41 test1-sym -&gt; test1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到， test1 的链接数从4减到3；</p>
<p>下一步，删除文件 test1 ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_operafile]$ rm -i test1</span><br><span class="line">rm：是否删除普通文件 &#x27;test1&#x27;？y</span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ ls -l</span><br><span class="line">总用量 8</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch 4096  1月  2 23:47 dir1</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch 4096  1月  2 23:49 dir2</span><br><span class="line">lrwxrwxrwx 1 lsjarch lsjarch    5  1月  2 23:41 test1-sym -&gt; test1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时 test1-sym 指向一个不存在的文件，是一个坏链接。在大多Linux发行版中会标红 test1-sym 以表示其是一个坏链接</span></span><br><span class="line">[lsjarch@LsjsArch test_operafile]$ less test1-sym </span><br><span class="line">test1-sym: 没有那个文件或目录</span><br><span class="line"><span class="meta">#</span><span class="bash"> 当尝试使用坏链接时，会报错。坏链接并不危险，除了会导致混乱</span></span><br></pre></td></tr></table></figure>
<p>对于符号链接，大多数文件操作是针对链接的对象，但<code>rm</code>命令是个特例，它会删除链接本身，而不是链接所指向的对象。</p>
<p>最后，删除 test_operafile ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_operafile]$ cd</span><br><span class="line">[lsjarch@LsjsArch ~]$ ls</span><br><span class="line">Desktop  Documents  Downloads  Music  Pictures  Postman  Public  Templates  test_operafile  Videos</span><br><span class="line">[lsjarch@LsjsArch ~]$ ls test_operafile/</span><br><span class="line">dir1  dir2  test1-sym</span><br><span class="line">[lsjarch@LsjsArch ~]$ rm -r test_operafile</span><br><span class="line">[lsjarch@LsjsArch ~]$ ls</span><br><span class="line">Desktop  Documents  Downloads  Music  Pictures  Postman  Public  Templates  Videos</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h2 id="五、使用命令">五、使用命令</h2>
<p>本章命令：<code>type</code>, <code>which</code>, <code>man</code>, <code>apropos</code>, <code>whatis</code>, <code>alias</code>。</p>
<h3 id="5-1到底什么是命令？">5.1	到底什么是命令？</h3>
<p>命令可以是下面四种形式之一：</p>
<ul>
<li>是一个可执行程序。属于这一类的程序，可以编译成二进制文件，如C/C++写成的程序，shell、perl、python、ruby等脚本语言写成的程序；</li>
<li>是一个内建于 shell 自身的命令。bash 支持若干命令，内部叫做 shell 内部命令（builtins）。如<code>cd</code>就是一个 shell 内部命令；</li>
<li>是一个 shell 函数。一些小规模的 shell 脚本，混合在环境变量中，后面会学习到如何配置环境变量及书写 shell 函数；</li>
<li>是一个命令别名。我们可以定义自己的命令，建立在其他命令之上；</li>
</ul>
<h3 id="5-2识别命令">5.2	识别命令</h3>
<p><code>type</code>：是 shell 内部命令，会显示命令的类别；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ type type</span><br><span class="line">type 是 shell 内建</span><br><span class="line">[lsjarch@LsjsArch ~]$ type ls</span><br><span class="line">ls 是“ls --color=auto”的别名</span><br><span class="line">[lsjarch@LsjsArch ~]$ type cp</span><br><span class="line">cp 是 /usr/bin/cp</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，Arch Linux中<code>ls</code>命令实际上是<code>ls --color=auto</code>的别名，这也是<code>ls</code>的输出有颜色的原因。</p>
<p><code>which</code>：确定所给定的执行程序的准确位置；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ type which</span><br><span class="line">which 是 /usr/bin/which</span><br><span class="line">[lsjarch@LsjsArch ~]$ which ls</span><br><span class="line">/usr/bin/ls</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个命令只对可执行程序有效，不包括内部命令和命令别名，别名只是可执行程序的替代物。当使用<code>which</code>定位 shell 内部命令时，要么没有回应，要么是报错信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ which cd</span><br><span class="line">which: no cd in (/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/lib/jvm/default/bin:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-3获得命令文档">5.3	获得命令文档</h3>
<p><code>help</code>：可以获得 shell 内部命令的文档，<code>help</code>是 bash 的内建帮助工具；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ help cd</span><br><span class="line">cd: cd [-L|[-P [-e]] [-@]] [目录]</span><br><span class="line">    改变 shell 工作目录。</span><br><span class="line">    </span><br><span class="line">    改变当前目录至 DIR 目录。默认的 DIR 目录是 shell 变量 HOME的值。</span><br><span class="line">    </span><br><span class="line">    变量 CDPATH 定义了含有 DIR 的目录的搜索路径，其中不同的目录名称由冒号 (:)分隔。</span><br><span class="line">    一个空的目录名称表示当前目录。如果要切换到的 DIR 由斜杠 (/) 开头，则 CDPATH 不会用上变量。</span><br><span class="line">    </span><br><span class="line">    如果路径找不到，并且 shell 选项 `cdable_vars&#x27; 被设定，则参数词被假定为一个变量名。如果该变量有值，则它的值被当作 DIR 目录。</span><br><span class="line">    </span><br><span class="line">    选项：</span><br><span class="line">        -L      强制跟随符号链接: 在处理 `..&#x27; 之后解析 DIR 中的符号链接。</span><br><span class="line">        -P      使用物理目录结构而不跟随符号链接: 在处理 `..&#x27; 之前解析 DIR 中的符号链接。</span><br><span class="line">        -e      如果使用了 -P 参数，但不能成功确定当前工作目录时，返回非零的返回值。</span><br><span class="line">        -@      在支持拓展属性的系统上，将一个有这些属性的文件当作有文件属性的目录。</span><br><span class="line">    </span><br><span class="line">    默认情况下跟随符号链接，如同指定 `-L&#x27;。</span><br><span class="line">    `..&#x27; 使用移除向前相邻目录名成员直到 DIR 开始或一个斜杠的方式处理。</span><br><span class="line">    </span><br><span class="line">    退出状态：</span><br><span class="line">    如果目录改变，或在使用 -P 选项时 $PWD 修改成功时返回 0，否则非零。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意表示法：命令语法说明中，[ ]中的内容表示可选项，“|”字符表示互斥项。</p>
<h3 id="5-4显示用法信息">5.4	显示用法信息</h3>
<p><code>--help</code>：显示可执行程序的用法信息，包括命令所支持的语法和选项说明；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ mkdir --help </span><br><span class="line">用法：mkdir [选项]... 目录...</span><br><span class="line">若指定&lt;目录&gt;不存在则创建目录。</span><br><span class="line"></span><br><span class="line">必选参数对长短选项同时适用。</span><br><span class="line">  -m, --mode=模式       设置权限模式（类似chmod），而不是 a=rwx 减 umask</span><br><span class="line">  -p, --parents         需要时创建目标目录的上层目录，但即使这些目录已存在也不当作错误处理，其文件权限模式不受 -m 选项影响。</span><br><span class="line">  -v, --verbose         每次创建新目录都显示信息</span><br><span class="line">  -Z                    设置每个创建的目录的 SELinux 安全上下文为默认类型</span><br><span class="line">      --context[=CTX]   类似 -Z，或如果指定了 CTX，则将 SELinux 或 SMACK 安全上下文设置为 CTX 对应的值</span><br><span class="line">      --help            显示此帮助信息并退出</span><br><span class="line">      --version         显示版本信息并退出</span><br><span class="line"></span><br><span class="line">GNU coreutils 在线帮助：&lt;https://www.gnu.org/software/coreutils/&gt;</span><br><span class="line">请向 &lt;http://translationproject.org/team/zh_CN.html&gt; 报告任何翻译错误</span><br><span class="line">完整文档 &lt;https://www.gnu.org/software/coreutils/mkdir&gt; 或者在本地使用：info &#x27;(coreutils) mkdir invocation&#x27;</span><br></pre></td></tr></table></figure>
<p>可能会有一些程序不支持<code>--help</code>选项，但试一下总不会吃亏。</p>
<h3 id="5-5显示程序手册页">5.5	显示程序手册页</h3>
<p><code>man</code>：是一个分页程序，用来浏览希望被命令行使用的可执行程序的正式文档；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Arch Linux 中默认没有 man 程序，先进行下载</span></span><br><span class="line">[lsjarch@LsjsArch ~]$ sudo pacman -S man</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 浏览一下 ls 程序的手册</span></span><br><span class="line">[lsjarch@LsjsArch ~]$ man ls</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>手册文档的格式一般包含一个标题，命令语法的纲要，命令用途的说明，和命令选项列表，及每个选项的说明。但并不包含实例，适合作为一本参考书。</p>
<p>大多数Linux系统中，<code>man</code>使用<code>less</code>工具来显示参考手册，所以<code>less</code>的命令都有效。</p>
<p><code>man</code>所显示的参考手册，被分成几个章节，不仅仅包括用户命令，也包括系统管理员命令、程序接口、文件格式等等。下表描述了手册的布局：</p>
<table>
<thead>
<tr>
<th style="text-align:left">章节</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td>用户命令</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td>程序接口内核系统调用</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td>C库函数程序接口</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td>特殊文件，如设备结点和驱动程序</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td>文件格式</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td>游戏娱乐，如屏幕保护程序</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td>其他方面</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td>系统管理员命令</td>
</tr>
</tbody>
</table>
<p>有时候，需要查看参考手册的特定章节，以得到所需信息。如果我们查找一种文件格式，同时也是一个命令名时，这种情况尤其正确。</p>
<p>没有指定章节号，我们总是得到第一个匹配项，可能在第一章节。如此使用<code>man</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 语法格式：man section search_term</span></span><br><span class="line">[lsjarch@LsjsArch ~]$ man 5 passwd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令运行结果会显示文件 /etc/passwd 的文件格式说明手册</span></span><br></pre></td></tr></table></figure>
<h3 id="5-6显示适当的命令">5.6	显示适当的命令</h3>
<p><code>apropos</code>：基于某个关键字的匹配项，搜索参考手册列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ apropos --help</span><br><span class="line">用法： apropos[选项...] 关键词...</span><br><span class="line"></span><br><span class="line">  -d, --debug                输出调试信息</span><br><span class="line">  -v, --verbose              输出详细的警告信息</span><br><span class="line">  -e, --exact                对每个关键词都进行严格匹配的搜索</span><br><span class="line">  -r, --regex                把每个关键词都当作正则表达式解读</span><br><span class="line">  -w, --wildcard             关键词里包含通配符</span><br><span class="line">  -a, --and                  要求所有的关键词都同时匹配</span><br><span class="line">  -l, --long                 不要把输出按终端宽度截断</span><br><span class="line">  -C, --config-file=文件     使用该用户设置文件</span><br><span class="line">  -L, --locale=区域          定义本次搜索所使用的区域设置</span><br><span class="line">  -m, --systems=系统         使用来自其它系统的手册页</span><br><span class="line">  -M, --manpath=路径         设置搜索手册页的路径为 PATH</span><br><span class="line">  -s, --sections=列表, --section=列表</span><br><span class="line">                             仅在这些分区中搜索（冒号分隔）</span><br><span class="line">  -?, --help                 显示此帮助列表</span><br><span class="line">      --usage                显示一份简洁的用法信息</span><br><span class="line">  -V, --version              打印程序版本</span><br><span class="line"></span><br><span class="line">选项完整形式所必须用的或是可选的参数，在使用选项缩写形式时也是必须的或是可选的。</span><br><span class="line"></span><br><span class="line">The --regex option is enabled by default.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果每行第一个字段是手册页的名字，第二个字段显示章节。<code>man -k</code>命令作用与<code>apropos</code>相同。</p>
<h3 id="5-7显示非常简洁的命令说明">5.7	显示非常简洁的命令说明</h3>
<p><code>whatis</code>：显示匹配特定关键字的手册页的名字和一行命令说明；</p>
<h3 id="5-8显示程序-Info-条目">5.8	显示程序 Info 条目</h3>
<p><code>info</code>：GNU项目提供的命令程序手册页的替代物。<code>info</code>内容可通过<code>info</code>阅读器程序读取，<code>info</code>页以超级链接形式展示，类似于网页。</p>
<p><code>info</code>程序读取<code>info</code>文件，<code>info</code>文件是树型结构，分化为各个结点，每一个包含一个题目。</p>
<p><code>info</code>文件包含超级链接，可以从一个结点跳到另一个结点。一个超级链接可通过开头的星号辨别，将光标放在其上并按下<kbd>enter</kbd>，即可激活它。</p>
<p>输入<code>info</code>，接着输入程序名称，即可启动<code>info</code>。下表命令可以用来控制<code>info</code>页面中的阅读器：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>?</td>
<td>显示命令帮助</td>
</tr>
<tr>
<td>PgUp or Backspace</td>
<td>显示上一页</td>
</tr>
<tr>
<td>PgDn or Space</td>
<td>显示下一页</td>
</tr>
<tr>
<td>n</td>
<td>下一个，显示下一个结点</td>
</tr>
<tr>
<td>p</td>
<td>上一个，显示上一个结点</td>
</tr>
<tr>
<td>u</td>
<td>Up，显示当前所显示结点的父结点，通常是个菜单</td>
</tr>
<tr>
<td>Enter</td>
<td>激活光标位置下的超级链接</td>
</tr>
<tr>
<td>q</td>
<td>退出</td>
</tr>
</tbody>
</table>
<p>目前为止，学习到的命令大多数与 GNU 项目的<code>coreutils</code>包，输入下面命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ info coreutils &#x27;ls&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行结果为</span></span><br><span class="line">Next: dir invocation,  Up: Directory listing</span><br><span class="line"></span><br><span class="line">10.1 ‘ls’: List directory contents</span><br><span class="line">==================================</span><br><span class="line"></span><br><span class="line">The ‘ls’ program lists information about files (of any type, including</span><br><span class="line">directories).  Options and file arguments can be intermixed arbitrarily,</span><br><span class="line">as usual.  Later options override earlier options that are incompatible.</span><br><span class="line"></span><br><span class="line">   For non-option command-line arguments that are directories, by</span><br><span class="line">default ‘ls’ lists the contents of directories, not recursively, and</span><br><span class="line">omitting files with names beginning with ‘.’.  For other non-option</span><br><span class="line">arguments, by default ‘ls’ lists just the file name.  If no non-option</span><br><span class="line">argument is specified, ‘ls’ operates on the current directory, acting as</span><br><span class="line">if it had been invoked with a single argument of ‘.’.</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不指定关键词时，将会显示一个包含超级链接的手册页，这些超级链接指向包含在<code>coreutils</code>包中的各个程序。</p>
<h3 id="5-9README和其他程序文档">5.9	README和其他程序文档</h3>
<p>许多安装在系统中的软件，都有自己的文档文件，位于/usr/share/doc目录下。这些文档大多以文本文件形式存储，可通过<code>less</code>程序阅读；对于HTML格式文档，通过网页浏览器来阅读；以<code>.gz</code>结尾的文件，表示已经通过了 gzip 程序的压缩，而 gzip 程序包含一个特殊的<code>less</code>版本，叫做<code>zless</code>，<code>zless</code>可以显示由 gzip 压缩的文本文件的内容。</p>
<h3 id="5-10用别名创建自己的命令">5.10	用别名创建自己的命令</h3>
<p>首先，要知道可以将多个命令放在同一行，命令之间用“<code>;</code>”分隔，并且按照先后顺序执行。</p>
<p>现在，创建第一个 shell 吧：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先看一下我们要实现的命令</span></span><br><span class="line">[lsjarch@LsjsArch ~]$ cd /usr; ls; cd ~</span><br><span class="line">bin  include  lib  lib32  lib64  local  sbin  share  src</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这串命令的作用是，先切换工作目录到 /usr 并 ls 其中的目录或文件，最后回到原始目录</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 要为这一串命令命名别名，先检查一下是否要命名的命令别名已经存在</span></span><br><span class="line">[lsjarch@LsjsArch ~]$ type test</span><br><span class="line">test 是 shell 内建</span><br><span class="line">[lsjarch@LsjsArch ~]$ type test_alias</span><br><span class="line">bash: type: test_alias：未找到</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> OK！test_alias命令还未被占用，创建该别名</span></span><br><span class="line">[lsjarch@LsjsArch ~]$ alias test_alias=&#x27;cd /usr; ls; cd ~&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试一下</span></span><br><span class="line">[lsjarch@LsjsArch ~]$ test_alias </span><br><span class="line">bin  include  lib  lib32  lib64  local  sbin  share  src</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看一下test_alias</span></span><br><span class="line">[lsjarch@LsjsArch ~]$ type test_alias </span><br><span class="line">test_alias 是“cd /usr; ls; cd ~”的别名</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除别名</span></span><br><span class="line">[lsjarch@LsjsArch ~]$ unalias test_alias </span><br><span class="line">[lsjarch@LsjsArch ~]$ type test_alias</span><br><span class="line">bash: type: test_alias：未找到</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 要查看定义在系统环境中的别名，使用不带参数的 <span class="built_in">alias</span> 命令</span></span><br><span class="line">[lsjarch@LsjsArch ~]$ alias </span><br><span class="line">alias ls=&#x27;ls --color=auto&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>尽管我们已经有意避免使用已经存在的命令名来作为我们自定义的别名，但这仍是常见的情况。</p>
<p>通常，我们会把一个普遍用到的选项加到一个经常使用的命令后面，如<code>ls</code>命令。</p>
<p>在命令行中定义别名有一个问题，那就是当 shell 会话结束时，它们会消失。后面将学到如何将自定义的别名添加到文件中去。</p>
<h3 id="5-11拓展阅读">5.11	拓展阅读</h3>
<ul>
<li>Bash 参考手册是一本 bash shell 的参考指南，里面有很多实例，且比 bash 手册页易于阅读：<a target="_blank" rel="noopener" href="https://www.gnu.org/software/bash/manual/bashref.html">https://www.gnu.org/software/bash/manual/bashref.html</a></li>
<li>Bash FAQ 包含关于 bash 及经常提到的问题的答案。这个列表面向 bash 的中高级用户，但有许多有帮助信息：<a target="_blank" rel="noopener" href="https://mywiki.wooledge.org/BashFAQ">https://mywiki.wooledge.org/BashFAQ</a></li>
<li>GNU 项目为其程序提供了详细的文档：<a target="_blank" rel="noopener" href="https://www.gnu.org/manual/manual.html">https://www.gnu.org/manual/manual.html</a></li>
<li>Wikipedia 上有一篇关于手册页的有趣文章：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Man_page">https://en.wikipedia.org/wiki/Man_page</a></li>
</ul>
<hr>
<h2 id="六、I-O重定向">六、I/O重定向</h2>
<p>通过这个工具，可以重定向命令的输入输出，实现命令的输入来自文件，输出也存储到文件。也可以将多个命令连接起来组成命令管道。</p>
<p>本章命令：<code>cat</code>, <code>sort</code>, <code>uniq</code>, <code>grep</code>, <code>wc</code>, <code>head</code>, <code>tail</code>。</p>
<h3 id="6-1标准输入、输出、错误">6.1	标准输入、输出、错误</h3>
<p>输出常常由两种类型组成——程序运行结果和得到的状态、错误信息。前者呈现了程序要完成的功能，后者说明了程序的进展。</p>
<p>Linux作为类Unix系统的“一切皆文件”的又一体现：程序，比如<code>ls</code>，将其运行结果输送到 stdout 文件，称为<code>标准输出</code>，将状态信息输送到 stderr 文件，称为<code>标准错误</code>。默认情况下，标准输出和标准错误都连接到屏幕，而不是保存到磁盘文件。同时，标准输入设备 stdin ，默认连接到键盘，作为程序的输入端。</p>
<p>而<code>I/O重定向</code>则用来改变输出走向和输入走向。</p>
<h3 id="6-2重定向标准输出">6.2	重定向标准输出</h3>
<p><code>&gt;</code>：重定向符，其后紧接文件名，可以将标准输出重定向到该文件；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ mkdir test_io</span><br><span class="line">[lsjarch@LsjsArch ~]$ ls -l</span><br><span class="line">总用量 40</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch 4096  1月  3 15:33 Desktop</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch 4096  1月  2 21:04 Documents</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch 4096  1月  2 01:08 Downloads</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch 4096 12月 28 18:41 Music</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch 4096 12月 28 18:41 Pictures</span><br><span class="line">drwxr-xr-x 3 lsjarch lsjarch 4096  1月  2 02:19 Postman</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch 4096 12月 28 18:41 Public</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch 4096 12月 28 18:41 Templates</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch 4096  1月  3 15:33 test_io</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch 4096 12月 28 18:41 Videos</span><br><span class="line">[lsjarch@LsjsArch ~]$ ls -l /usr/bin &gt; test_io/ls-output.txt</span><br><span class="line">[lsjarch@LsjsArch ~]$ less test_io/ls-output.txt </span><br><span class="line"><span class="meta">#</span><span class="bash"> 在less程序中，可以看到结果被成功存储</span></span><br><span class="line"></span><br><span class="line">[lsjarch@LsjsArch ~]$ ls -l test_io/ls-output.txt </span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch 131756  1月  3 15:34 test_io/ls-output.txt</span><br></pre></td></tr></table></figure>
<p>如果我们换成一个不存在的目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[lsjarch@LsjsArch ~]$ ls -l /bin/usr &gt; test_io/ls-wrong.txt</span><br><span class="line">ls: 无法访问 &#x27;/bin/usr&#x27;: 没有那个文件或目录</span><br><span class="line">[lsjarch@LsjsArch ~]$ ls -l test_io/ls-wrong.txt </span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch 0  1月  3 15:40 test_io/ls-wrong.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>ls</code>并不把它的错误信息作为标准输出或重定向，而是直接显示在屏幕上。因为我们并没有对标准错误进行重定向，所以不会将错误信息存储在文件中。</p>
<p>并且，注意到<code>ls-wrong.txt</code>文件长度为0，这是因为文件总是从开头被重写，而<code>ls</code>命令没有产生正确的输出结果，所以重定向操作重写文件时由于错误而停止，导致文件内容删除。事实上，可以据此实现删除文件的全部内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先向ls-wrong.txt文件中写入一些字符</span></span><br><span class="line">[lsjarch@LsjsArch ~]$ vim test_io/ls-wrong.txt </span><br><span class="line">[lsjarch@LsjsArch ~]$ ls -l test_io/ls-wrong.txt </span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch 14  1月  3 15:49 test_io/ls-wrong.txt</span><br><span class="line">[lsjarch@LsjsArch ~]$ ls -l /bin/usr &gt; test_io/ls-wrong.txt </span><br><span class="line">ls: 无法访问 &#x27;/bin/usr&#x27;: 没有那个文件或目录</span><br><span class="line">[lsjarch@LsjsArch ~]$ ls -l test_io/ls-wrong.txt </span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch 0  1月  3 15:56 test_io/ls-wrong.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 事实上，在重定向命令中，重定向符 &gt; 前的内容是不必要的，即使删除也可以清空已存在文件的内容</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果重定向符 &gt; 指向的文件并不存在呢？</span></span><br><span class="line">[lsjarch@LsjsArch ~]$ cd test_io</span><br><span class="line">[lsjarch@LsjsArch test_io]$ ls</span><br><span class="line">ls-output.txt  ls-wrong.txt</span><br><span class="line">[lsjarch@LsjsArch test_io]$ &gt; test1.txt</span><br><span class="line">[lsjarch@LsjsArch test_io]$ ls -l</span><br><span class="line">总用量 132</span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch 131756  1月  3 15:34 ls-output.txt</span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch      0  1月  3 15:56 ls-wrong.txt</span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch      0  1月  3 16:02 test1.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可见，会创建一个空文件</span></span><br></pre></td></tr></table></figure>
<p>那么，怎样实现追加重定向结果到文件原内容的后面，而不是从开头重写文件？<code>&gt;&gt;</code>重定向符可以做到这件事：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_io]$ ls -l /usr/bin &gt;&gt; ls-output.txt </span><br><span class="line">[lsjarch@LsjsArch test_io]$ ls -l ls-output.txt </span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch 263512  1月  3 16:06 ls-output.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以看到，文件大小变为原来的两倍</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同样，如果 &gt;&gt; 指向的文件不存在，会自动创建并存储重定向的输出</span></span><br></pre></td></tr></table></figure>
<h3 id="6-3重定向标准错误">6.3	重定向标准错误</h3>
<p>重定向标准错误没有专用操作符，我们需要参考其文件描述符。</p>
<p>一个程序可以在几个编号的文件流中的任一个上产生输出，我们将这些文件流的前三个定义作标准输入、输出和错误，shell 内部参考它们为文件描述符为0、1、2。因此，当我们使用文件描述符来为标准错误进行重定向：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_io]$ ls -l /usr/bin 2&gt; ls-error.txt</span><br><span class="line">...</span><br><span class="line">-rwxr-xr-x 1 root root     4553  9月  4 10:01  znew</span><br><span class="line">-rwxr-xr-x 1 root root   116904 12月  2 04:14  zramctl</span><br><span class="line">-rwxr-xr-x 1 root root    23064  1月  8  2021  zresample</span><br><span class="line">-rwxr-xr-x 1 root root    23032  1月  8  2021  zretune</span><br><span class="line">lrwxrwxrwx 1 root root        6  6月 22  2021  zsoelim -&gt; soelim</span><br><span class="line">-rwxr-xr-x 1 root root  1108824 12月 24 18:18  zstd</span><br><span class="line">lrwxrwxrwx 1 root root        4 12月 24 18:18  zstdcat -&gt; zstd</span><br><span class="line">-rwxr-xr-x 1 root root     3869 12月 24 18:18  zstdgrep</span><br><span class="line">-rwxr-xr-x 1 root root       30 12月 24 18:18  zstdless</span><br><span class="line">lrwxrwxrwx 1 root root       13 12月 24 18:18  zstdmt -&gt; /usr/bin/zstd</span><br><span class="line"></span><br><span class="line">[lsjarch@LsjsArch test_io]$ ls -l</span><br><span class="line">总用量 260</span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch      0  1月  3 16:46 ls-error.txt</span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch 263512  1月  3 16:06 ls-output.txt</span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch      0  1月  3 15:56 ls-wrong.txt</span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch      0  1月  3 16:02 test1.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>文件描述符<code>2</code>，紧挨着放在重定向操作符之前，来执行重定向标准错误到文件<code>ls-error.txt</code>的任务。</p>
<p><strong>重定向标准输出和标准错误到同一个文件：</strong></p>
<ul>
<li>
<p>传统方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_io]$ ls -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1</span><br><span class="line">[lsjarch@LsjsArch test_io]$ ls -l</span><br><span class="line">总用量 4</span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch  0  1月  3 16:46 ls-error.txt</span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch 57  1月  3 16:52 ls-output.txt</span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch  0  1月  3 15:56 ls-wrong.txt</span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch  0  1月  3 16:02 test1.txt</span><br><span class="line">[lsjarch@LsjsArch test_io]$ less ls-output.txt </span><br><span class="line">ls: 无法访问 &#x27;/bin/usr&#x27;: 没有那个文件或目录</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述命令完成了两个重定向，首先重定向标准输出到文件<code>ls-output.txt</code>，然后重定向文件描述符<code>2</code>到文件描述符<code>1</code>，使用表示法<code>2&gt;&amp;1</code>。</p>
<p>注意，重定向的顺序安排很重要，标准错误的重定向必须总是在标准输出重定向之后，不然不起作用</p>
</li>
<li>
<p>联合表示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_io]$ ls -l /bin/usr &amp;&gt; ls-output.txt </span><br><span class="line">[lsjarch@LsjsArch test_io]$ ls -l</span><br><span class="line">总用量 4</span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch  0  1月  3 16:46 ls-error.txt</span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch 57  1月  3 17:02 ls-output.txt</span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch  0  1月  3 15:56 ls-wrong.txt</span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch  0  1月  3 16:02 test1.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，我们使用<code>&amp;&gt;</code>联合表示重定向标准输出和标准错误。</p>
</li>
</ul>
<p><strong>处理不需要的输出：</strong></p>
<p>对于错误信息和状态信息，我们不总是需要其输出，那么通过重定向输出结果到一个特殊的文件<code>/dev/null</code>。</p>
<p>这个文件是系统设备，叫做位存储桶，它可以接受输入，并对输入不做任何处理。所以，为了隐瞒命令错误信息，可以这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_io]$ ls -l /bin/usr 2&gt; /dev/null</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="6-4重定向标准输入">6.4	重定向标准输入</h3>
<p>事实上，我们用键盘在<code>terminal</code>中输入命令，就是利用标准输入。<strong>那么，要怎么进行重定向呢？</strong></p>
<p><code>cat</code>：读取一个或多个文件，然后复制它们到标准输出；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 为避免歧义，我们先修改一下文件里的内容</span></span><br><span class="line">[lsjarch@LsjsArch test_io]$ vim ls-output.txt </span><br><span class="line">[lsjarch@LsjsArch test_io]$ cat ls-output.txt </span><br><span class="line">hello,world!</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>事实上，<code>cat</code>命令用来显示文件而没有分页，因此常用来显示简短的文本文件。又由于<code>cat</code>可以接受不止一个文件作为参数，所以也可以用来把文件连接在一起：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat movie.mpeg.0* &gt; movie.mpeg</span><br><span class="line"><span class="meta">#</span><span class="bash"> USENET中的多媒体文件常分离成多个部分，若要连接，则使用上述命令。由于通配符总是以有序的方式展开，所以这些部分文件的参数会以正确的顺序安排</span></span><br></pre></td></tr></table></figure>
<p>那么，这些和重定向标准输入有什么关系呢？欸，没有任何关系。。</p>
<p>呃，just a joke~</p>
<p>尝试不带参数的<code>cat</code>命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_io]$ cat </span><br><span class="line">test cat cmd without parameter.</span><br></pre></td></tr></table></figure>
<p>下一步使用组合键<kbd>ctrl</kbd>+<kbd>d</kbd>来告诉<code>cat</code>，在标准输入中，它已经到达了文件末尾 EOF ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_io]$ cat </span><br><span class="line">test cat cmd without parameter.test cat cmd without parameter.</span><br></pre></td></tr></table></figure>
<p>由于文件名参数的缺席，<code>cat</code>仅仅是复制标准输入到标准输出，所以文本行会重复出现。那么，加上重定向输出的目标文件，就可以实现从标准输入重定向输出到目标文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_io]$ cat &gt; test_cat.txt</span><br><span class="line">test cat cmd with target file.^C</span><br><span class="line">[lsjarch@LsjsArch test_io]$ cat test_cat.txt </span><br><span class="line">test cat cmd with target file.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>了解了如何接受标准输入，接下来尝试重定向标准输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_io]$ cat &lt; test_cat.txt </span><br><span class="line">test cat cmd with target.</span><br></pre></td></tr></table></figure>
<p><code>&lt;</code>：重定向输入符，将标准输入源从键盘改到文件 test_cat.txt 。</p>
<h3 id="6-5管道线">6.5	管道线</h3>
<p>管道线是一种 shell 的特性，它利用了命令能从标准输入读取数据再将数据输送到标准输出的原理。使用管道操作符“<code>|</code>”，一个命令的标准输出可以通过管道到达另一个命令的标准输入。</p>
<p>回顾之前学习的<code>less</code>命令，其实它还是一个能接受标准输入的命令。我们用<code>less</code>来一页一页地显示任何命令的输出，命令把它的运行结果输送到标准输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_io]$ ls -l /usr/bin | less</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用管道线，可以方便地检测会产生标准输出的任一命令的运行结果。</p>
<h3 id="6-6过滤器">6.6	过滤器</h3>
<p>管道线经常用来对数据完成复杂的操作，为了使结果易读，我们需要过滤器对输出结果优化。</p>
<p><code>sort</code>：改变输出数据，使其称为一个有序列表，默认是升序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_io]$ ls /bin /usr/bin | sort | less</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="6-7报道或忽略重复行">6.7	报道或忽略重复行</h3>
<p><code>uniq</code>：从标准输入或单个文件名参数接受数据有序列表，然后从数据列表中删除任何重复行。常和<code>sort</code>命令结合使用；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_io]$ ls /bin /usr/bin | sort | uniq | less</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果为<code>uniq -d</code>，则会看到重复行。</p>
<h3 id="6-8打印行，字节和字节数">6.8	打印行，字节和字节数</h3>
<p><code>wc</code>：用来显示文件所包含的行、字及字节数；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_io]$ cat test_cat.txt </span><br><span class="line">test cat cmd with target.</span><br><span class="line"></span><br><span class="line">[lsjarch@LsjsArch test_io]$ wc test_cat.txt </span><br><span class="line"> 2  5 27 test_cat.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果<code>wc</code>不带命令行参数，则接受标准输入。添加<code>-l</code>选项可以限制命令输出只能报道行数。因此，添加<code>wc</code>到管道线可以用来统计数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_io]$ ls /bin /usr/bin | sort | uniq | wc </span><br><span class="line">   2215    2214   23082</span><br></pre></td></tr></table></figure>
<h3 id="6-9打印匹配行">6.9	打印匹配行</h3>
<p><code>grep</code>：用来寻找文件中匹配的文本；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep pattern [file...]</span><br></pre></td></tr></table></figure>
<p>当<code>grep</code>遇到一个文件中匹配的“模式/pattern”，就会打印出包含这个类型的所有行。<code>pattern</code>可以是简单的文本匹配，也可以是后面要学到的正则表达式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 若我们需要了解文件名中包含 zip 的情况，以获取系统中一些程序与文件压缩的关系</span></span><br><span class="line">[lsjarch@LsjsArch test_io]$ ls /bin /usr/bin | sort | uniq | grep zip</span><br><span class="line">bunzip2</span><br><span class="line">bzip2</span><br><span class="line">bzip2recover</span><br><span class="line">gunzip</span><br><span class="line">gzip</span><br><span class="line">zipcmp</span><br><span class="line">zipmerge</span><br><span class="line">ziptool</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，在Linux系统中是大小写敏感的，若要忽略大小写进行匹配，则需要为<code>grep</code>添加<code>-i</code>选项。而<code>-v</code>则会让<code>grep</code>只打印不匹配的行。</p>
<h3 id="6-10打印文件开头-结尾部分">6.10	打印文件开头/结尾部分</h3>
<p><code>head</code>：打印文件前十行；</p>
<p><code>tail</code>：打印文件后十行。两个命令都可以通过<code>-n</code>选项来指定所要打印的行数；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_io]$ ls -l /usr/bin &gt; ls-output.txt </span><br><span class="line">[lsjarch@LsjsArch test_io]$ ls -l</span><br><span class="line">总用量 136</span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch      0  1月  3 16:46 ls-error.txt</span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch 131756  1月  4 00:36 ls-output.txt</span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch      0  1月  3 15:56 ls-wrong.txt</span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch      0  1月  3 16:02 test1.txt</span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch     27  1月  3 23:38 test_cat.txt</span><br><span class="line">[lsjarch@LsjsArch test_io]$ head -n 8 ls-output.txt </span><br><span class="line">总用量 612068</span><br><span class="line">-rwxr-xr-x 1 root root    59552  9月 29 21:56 [</span><br><span class="line">lrwxrwxrwx 1 root root        9 12月 19 07:53 2to3 -&gt; 2to3-3.10</span><br><span class="line">-rwxr-xr-x 1 root root       96 12月 19 07:53 2to3-3.10</span><br><span class="line">-rwxr-xr-x 1 root root    14176 10月 15  2020 4channels</span><br><span class="line">-rwxr-xr-x 1 root root    14408  6月 22  2021 accessdb</span><br><span class="line">-rwxr-xr-x 2 root root    36020 10月  5 03:45 aclocal</span><br><span class="line">-rwxr-xr-x 2 root root    36020 10月  5 03:45 aclocal-1.16</span><br><span class="line">[lsjarch@LsjsArch test_io]$ tail ls-output.txt </span><br><span class="line">-rwxr-xr-x 1 root root     4553  9月  4 10:01 znew</span><br><span class="line">-rwxr-xr-x 1 root root   116904 12月  2 04:14 zramctl</span><br><span class="line">-rwxr-xr-x 1 root root    23064  1月  8  2021 zresample</span><br><span class="line">-rwxr-xr-x 1 root root    23032  1月  8  2021 zretune</span><br><span class="line">lrwxrwxrwx 1 root root        6  6月 22  2021 zsoelim -&gt; soelim</span><br><span class="line">-rwxr-xr-x 1 root root  1108824 12月 24 18:18 zstd</span><br><span class="line">lrwxrwxrwx 1 root root        4 12月 24 18:18 zstdcat -&gt; zstd</span><br><span class="line">-rwxr-xr-x 1 root root     3869 12月 24 18:18 zstdgrep</span><br><span class="line">-rwxr-xr-x 1 root root       30 12月 24 18:18 zstdless</span><br><span class="line">lrwxrwxrwx 1 root root       13 12月 24 18:18 zstdmt -&gt; /usr/bin/zstd</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这两个命令还能用在管道线中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_io]$ ls /usr/bin | tail -n 5</span><br><span class="line">zstd</span><br><span class="line">zstdcat</span><br><span class="line">zstdgrep</span><br><span class="line">zstdless</span><br><span class="line">zstdmt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>tail</code>的<code>-f</code>选项允许实时浏览文件，这在观察日志文件的进展时非常有用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_io]$ tail -f /var/log/pacman.log </span><br><span class="line">[2022-01-03T02:13:05+0800] [PACMAN] Running &#x27;pacman -S aprops&#x27;</span><br><span class="line">[2022-01-03T02:13:12+0800] [PACMAN] Running &#x27;pacman -S apropos&#x27;</span><br><span class="line">[2022-01-03T13:53:28+0800] [PACKAGEKIT] synchronizing package lists</span><br><span class="line">[2022-01-03T23:08:47+0800] [PACKAGEKIT] synchronizing package lists</span><br><span class="line">[2022-01-03T23:46:13+0800] [ALPM] transaction started</span><br><span class="line">[2022-01-03T23:46:13+0800] [ALPM] upgraded yay (11.0.2-1 -&gt; 11.1.0-1)</span><br><span class="line">[2022-01-03T23:46:13+0800] [PACKAGEKIT] upgraded yay (11.0.2-1 -&gt; 11.1.0-1)</span><br><span class="line">[2022-01-03T23:46:13+0800] [ALPM] transaction completed</span><br><span class="line">[2022-01-03T23:46:13+0800] [ALPM] running &#x27;30-systemd-update.hook&#x27;...</span><br><span class="line">[2022-01-03T23:46:13+0800] [ALPM] running &#x27;90-packagekit-refresh.hook&#x27;...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>tail</code>会持续监测这个文件，直到有新内容添加时会立即输出到屏幕，这会一直持续直到<kbd>ctrl</kbd>+<kbd>c</kbd>退出。</p>
<h3 id="6-11从-stdin-读取数据，并同时输出到-stdout-和文件">6.11	从 stdin 读取数据，并同时输出到 stdout 和文件</h3>
<p>为了和管道隐喻保持一致，Linux提供了一个名为<code>tee</code>的命令。</p>
<p><code>tee</code>会制造一个“tee”并安装在管道上，<code>tee</code>程序从标准输入读入数据，并且同时复制数据到标准输出（允许数据继续随着管道线流动）和一个或多个文件。这对某个中间处理阶段捕获一个管道线内容时非常有帮助；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过 tee 实现在 grep 过滤管道线内容之前，捕获整个目录列表到文件 test_tee.txt</span></span><br><span class="line">[lsjarch@LsjsArch test_io]$ ls /usr/bin | tee test_tee.txt | grep zip</span><br><span class="line">bunzip2</span><br><span class="line">bzip2</span><br><span class="line">bzip2recover</span><br><span class="line">gunzip</span><br><span class="line">gzip</span><br><span class="line">zipcmp</span><br><span class="line">zipmerge</span><br><span class="line">ziptool</span><br><span class="line">[lsjarch@LsjsArch test_io]$ ls -l test_tee.txt </span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch 23065  1月  4 00:55 test_tee.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="七、shell-中的展开模式">七、shell 中的展开模式</h2>
<p>本章命令：<code>echo</code>。</p>
<p>开始之前，先来看一下<code>echo</code>的文档吧：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ help echo</span><br><span class="line">echo: echo [-neE] [参数 ...]</span><br><span class="line">    将参数写到标准输出。</span><br><span class="line">    </span><br><span class="line">    在标准输出上，显示用空格分割的 ARG 参数后跟一个换行。</span><br><span class="line">    </span><br><span class="line">    选项：</span><br><span class="line">      -n        不要追加换行</span><br><span class="line">      -e        启用下列反斜杠转义的解释</span><br><span class="line">      -E        显式地抑制对于反斜杠转义的解释</span><br><span class="line">    </span><br><span class="line">    `echo&#x27; 对下列反斜杠字符进行转义：</span><br><span class="line">        警告(响铃)</span><br><span class="line">      \b        退格</span><br><span class="line">      \c        抑制更多的输出</span><br><span class="line">      \e        转义字符</span><br><span class="line">      \f        换页字符</span><br><span class="line">      \n        换行</span><br><span class="line">      \r        回车</span><br><span class="line">      \t        横向制表符</span><br><span class="line">      \v        纵向制表符</span><br><span class="line">      \\        反斜杠</span><br><span class="line">      \0nnn     以 NNN（八进制）为 ASCII 码的字符。NNN 可以是 0 到 3 个八进制位</span><br><span class="line">      \xHH      以 HH（十六进制）为值的八比特字符。HH 可以是一个或两个十六进制位</span><br><span class="line">      \uHHHH    以 HHHH（十六进制）为值的 Unicode 字符。HHHH 可以是一个到四个十六进制位。</span><br><span class="line">      \UHHHHHHHH 以 HHHHHHHH（十六进制）为值的 Unicode 字符。HHHHHHHH 可以是一到八个十六进制位。</span><br><span class="line">    </span><br><span class="line">    退出状态：</span><br><span class="line">    返回成功除非有写错误发生。</span><br></pre></td></tr></table></figure>
<h3 id="7-1字符展开">7.1	字符展开</h3>
<p>每一次从输入命令到摁下<kbd>Enter</kbd> bash执行命令之前，bash 会对输入的字符进行展开。让我们用<code>echo</code>来说明：</p>
<p><code>echo</code>：是一个 shell 内部命令，用来在标准输出中打印它的所有文本参数；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_io]$ echo this is echo test</span><br><span class="line">this is echo test</span><br><span class="line"></span><br><span class="line">[lsjarch@LsjsArch test_io]$ echo *</span><br><span class="line">ls-error.txt ls-output.txt ls-wrong.txt test1.txt test_cat.txt test_tee.txt</span><br><span class="line">[lsjarch@LsjsArch test_io]$ mkdir test_echo</span><br><span class="line">[lsjarch@LsjsArch test_io]$ echo *</span><br><span class="line">ls-error.txt ls-output.txt ls-wrong.txt test1.txt test_cat.txt test_echo test_tee.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为什么<code>echo</code>不打印 “*” 呢？因为此处 shell 将通配符 * 展开成当前工作目录下全部文件或目录的名字（或任何符合条件的字符），然后再调用命令<code>echo</code>。</p>
<h3 id="7-2路径名展开">7.2	路径名展开</h3>
<p>上面通配符的工作机制称为路径名展开。再来试试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ ls</span><br><span class="line">cd  Desktop  Documents  Downloads  Music  Pictures  Postman  Public  Templates  test_io  Videos</span><br><span class="line">[lsjarch@LsjsArch ~]$ echo D*</span><br><span class="line">Desktop Documents Downloads</span><br><span class="line">[lsjarch@LsjsArch ~]$ echo [[:upper:]]*</span><br><span class="line">Desktop Documents Downloads Music Pictures Postman Public Templates Videos</span><br><span class="line">[lsjarch@LsjsArch ~]$ echo /usr/*/share</span><br><span class="line">/usr/*/share</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><em><strong>关于隐藏文件路径名的展开</strong></em></p>
<p>当使用 <code>echo *</code>这样并不会显示隐藏文件。那么，若加上一个圆点开头呢？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ ls -a</span><br><span class="line">.              .bash_profile  .config    .gtkrc-2.0  .lesshst  Pictures  .python_history  Videos      .Xauthority</span><br><span class="line">..             .bashrc        Desktop    .icons      .local    .pki      Templates        .viminfo    .xprofile</span><br><span class="line">.bash_history  .cache         Documents  .java       .mozilla  Postman   test_io          .vscode</span><br><span class="line">.bash_logout   cd             Downloads  .kde4       Music     Public    .themes          .wget-hsts</span><br><span class="line">[lsjarch@LsjsArch ~]$ echo *</span><br><span class="line">cd Desktop Documents Downloads Music Pictures Postman Public Templates test_io Videos</span><br><span class="line">[lsjarch@LsjsArch ~]$ echo .*</span><br><span class="line">. .. .bash_history .bash_logout .bash_profile .bashrc .cache .config .gtkrc-2.0 .icons .java .kde4 .lesshst .local .mozilla .pki .python_history .themes .viminfo .vscode .wget-hsts .Xauthority .xprofile</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>奇怪的是，. 和 … 这两个字符也被输出了，但这表示的是当前目录及其父目录。因此，使用<code>echo .*</code>命令可能会导致错误。</p>
<p>换个命令试试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ ls -d .* | less</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出结果是</span></span><br><span class="line">.</span><br><span class="line">..</span><br><span class="line">.bash_history</span><br><span class="line">.bash_logout</span><br><span class="line">.bash_profile</span><br><span class="line">.bashrc</span><br><span class="line">.cache</span><br><span class="line">.config</span><br><span class="line">.gtkrc-2.0</span><br><span class="line">.icons</span><br><span class="line">.java</span><br><span class="line">.kde4</span><br><span class="line">.lesshst</span><br><span class="line">.local</span><br><span class="line">.mozilla</span><br><span class="line">.pki</span><br><span class="line">.python_history</span><br><span class="line">.themes</span><br><span class="line">.viminfo</span><br><span class="line">.vscode</span><br><span class="line">.wget-hsts</span><br><span class="line">.Xauthority</span><br><span class="line">.xprofile</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 让我们更精确一些</span></span><br><span class="line">[lsjarch@LsjsArch ~]$ ls -d .[!.]?* </span><br><span class="line">.bash_history  .bashrc  .gtkrc-2.0  .kde4     .mozilla         .themes   .wget-hsts</span><br><span class="line">.bash_logout   .cache   .icons      .lesshst  .pki             .viminfo  .Xauthority</span><br><span class="line">.bash_profile  .config  .java       .local    .python_history  .vscode   .xprofile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这表示显示文件名第一个字符为 . 且第二个字符不为 . 且至少还有一个字符的文件。这个命令能够列出大多数隐藏文件，但仍不能包含以多个圆点开头的文件名</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7-3波浪线展开">7.3	波浪线展开</h3>
<p>波浪线字符<code>~</code>用在一个单词开头时，它会展开成指定用户的家目录名，如果没有指定用户名则默认是当前用户的家目录；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ echo ~</span><br><span class="line">/home/lsjarch</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7-4算数表达式展开">7.4	算数表达式展开</h3>
<p>shell 允许算数表达式通过展开来执行；算数表达式只支持整数，且操作有+、-、*、/、%、**(取幂)五种。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ echo $((1+1))</span><br><span class="line">2</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 表达式中空格并不重要，并且支持嵌套</span></span><br><span class="line">[lsjarch@LsjsArch ~]$ echo $(($((5**2))*  3))</span><br><span class="line">75</span><br><span class="line">[lsjarch@LsjsArch ~]$ echo $(((5**2)*3))</span><br><span class="line">75</span><br><span class="line"></span><br><span class="line">[lsjarch@LsjsArch ~]$ echo $((5/2))</span><br><span class="line">2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意到，小数部分会直接舍弃</span></span><br></pre></td></tr></table></figure>
<h3 id="7-5花括号展开">7.5	花括号展开</h3>
<p>通过花括号展开，可以从一个包含花括号的模式中创建多个文本字符串：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ echo Front-&#123;A,B,C&#125;-Back</span><br><span class="line">Front-A-Back Front-B-Back Front-C-Back</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>花括号展开模式可能包含一个开头部分叫做报头，一个结尾部分叫做附言。花括号表达式本身可能包含一个由逗号分开的字符串列表，或者一系列整数，或者单个字符串，但不能是空白字符：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ echo Number_&#123;1..5&#125;</span><br><span class="line">Number_1 Number_2 Number_3 Number_4 Number_5</span><br><span class="line"></span><br><span class="line">[lsjarch@LsjsArch ~]$ echo &#123;Z..A&#125;</span><br><span class="line">Z Y X W V U T S R Q P O N M L K J I H G F E D C B A</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 支持嵌套</span></span><br><span class="line">[lsjarch@LsjsArch ~]$ echo a&#123;A&#123;1,2&#125;,B&#123;2,3&#125;&#125;b</span><br><span class="line">aA1b aA2b aB2b aB3b</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>花括号展开有什么用？最普遍的应用是，创建一系列的文件或目录列表：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ mkdir test_&#123;&#125;</span><br><span class="line">[lsjarch@LsjsArch ~]$ cd test_\&#123;\&#125;/</span><br><span class="line">[lsjarch@LsjsArch test_&#123;&#125;]$ mkdir &#123;2021..2000&#125;-&#123;7,6&#125;</span><br><span class="line">[lsjarch@LsjsArch test_&#123;&#125;]$ ls</span><br><span class="line">2000-6  2001-7  2003-6  2004-7  2006-6  2007-7  2009-6  2010-7  2012-6  2013-7  2015-6  2016-7  2018-6  2019-7  2021-6</span><br><span class="line">2000-7  2002-6  2003-7  2005-6  2006-7  2008-6  2009-7  2011-6  2012-7  2014-6  2015-7  2017-6  2018-7  2020-6  2021-7</span><br><span class="line">2001-6  2002-7  2004-6  2005-7  2007-6  2008-7  2010-6  2011-7  2013-6  2014-7  2016-6  2017-7  2019-6  2020-7</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7-6参数展开">7.6	参数展开</h3>
<p>参数展开的特性在 shell 脚本中比命令行中更有用。它的性能和系统存储小块数据、并给每块数据命名的能力有关。许多这样的小块数据，更应称为变量，可以通过<code>echo</code>展开：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_&#123;&#125;]$ echo $USER</span><br><span class="line">lsjarch</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这表示USER变量中存储的是用户名。若要查看有效的变量列表，试试这个命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_&#123;&#125;]$ printenv | less</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果误输入一个模式，展开就不会发生，<code>echo</code>命令只简单地显示误键入模式。如果输错变量名，展开仍会进行，只不过是一个空字符串。</p>
<h3 id="7-7命令替换">7.7	命令替换</h3>
<p>命令替换允许我们把一个命令的输出作为一个展开模式来使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ echo $(ls)</span><br><span class="line">Desktop Documents Downloads Music Pictures Postman Public Templates test_&#123;&#125; Videos</span><br><span class="line"></span><br><span class="line">[lsjarch@LsjsArch ~]$ ls -l $(which cp)</span><br><span class="line">-rwxr-xr-x 1 root root 129216  9月 29 21:56 /usr/bin/cp</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里将括号内命令的执行结果作为参数传递给<code>ls</code>命令。</p>
<p>不止简单命令，整个管道线也可以作为参数传递：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ file $(ls /usr/bin/* | grep zip)</span><br><span class="line">/usr/bin/bunzip2:      symbolic link to bzip2</span><br><span class="line">/usr/bin/bzip2:        ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=bac992d1c92699d8fda1909fafa696cf522e3308, for GNU/Linux 3.2.0, stripped</span><br><span class="line">/usr/bin/bzip2recover: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=8e6d08aa02feac4a5259e97f1d265805bcd06a39, for GNU/Linux 3.2.0, stripped</span><br><span class="line">/usr/bin/gunzip:       POSIX shell script, ASCII text executable</span><br><span class="line">/usr/bin/gzip:         ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=39185aae1a17013de5f71b72c83990b833fe13a2, for GNU/Linux 4.4.0, stripped</span><br><span class="line">/usr/bin/zipcmp:       ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=06c8a61d22a392a3190a24dfa5e5c3cdd6c84e9c, for GNU/Linux 4.4.0, stripped</span><br><span class="line">/usr/bin/zipmerge:     ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=1612e190206dfa272ac681c9b03b8f89d70de45e, for GNU/Linux 4.4.0, stripped</span><br><span class="line">/usr/bin/ziptool:      ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=2ae0a15c96381cfa5f9a671200a1785f252b3afe, for GNU/Linux 4.4.0, stripped</span><br><span class="line">streamzip:             cannot open `streamzip&#x27; (No such file or directory)</span><br><span class="line">zipdetails:            cannot open `zipdetails&#x27; (No such file or directory)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另外，在旧版 shell 程序中，` `  可以代替<code>$()</code>。</p>
<h3 id="7-8引用">7.8	引用</h3>
<p>shell 使用引用机制来有选择地禁止不需要的展开：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ echo this is a   test</span><br><span class="line">this is a test</span><br><span class="line"><span class="meta">#</span><span class="bash"> shell 从 <span class="built_in">echo</span> 命令的参数列表中删除多余的空格</span></span><br><span class="line"></span><br><span class="line">[lsjarch@LsjsArch ~]$ echo The total is $110.00</span><br><span class="line">The total is 10.00</span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数展开把 <span class="variable">$1</span> 展开为一个空字符串，因为1是没有定义的变量</span></span><br></pre></td></tr></table></figure>
<p><em><strong>引用有两种类型：</strong></em></p>
<ul>
<li>
<p>双引号</p>
<ul>
<li>
<p>如果将文本放在双引号中，shell 使用的特殊字符，除 $ 和 \ 以及 ‘ 之外，都将失去其特殊含义。</p>
</li>
<li>
<p>这意味着单词分割、路径名展开、波浪线展开、花括号展开等方式都将被禁止。而参数展开、算数展开和命令替换仍可执行；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_quote]$ echo &quot;$USER $((1+1)) $(cal)&quot;</span><br><span class="line">lsjarch 2       一月 2022     </span><br><span class="line">一 二 三 四 五 六 日</span><br><span class="line">                1  2</span><br><span class="line"> 3  4  5  6  7  8  9</span><br><span class="line">10 11 12 13 14 15 16</span><br><span class="line">17 18 19 20 21 22 23</span><br><span class="line">24 25 26 27 28 29 30</span><br><span class="line">31 </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用双引号，可以处理包含空格的文件名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_quote]$ cat &gt; &quot;double quotation marks test.txt&quot;</span><br><span class="line">hello,world</span><br><span class="line">[lsjarch@LsjsArch test_quote]$ ls</span><br><span class="line">&#x27;double quotation marks test.txt&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>借此可以防止单词分割，得到期望结果</p>
</li>
<li>
<p>先来回顾一下单词分割机制中对空格的处理：默认情况下，单词分割机制会在单词中寻找空格、制表符、换行符，并将其看作单词之间的界定符。而双引号内单词分割被禁止，内嵌空格不再被当作分隔符：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_quote]$ echo this is a    test</span><br><span class="line">this is a test</span><br><span class="line">[lsjarch@LsjsArch test_quote]$ echo &quot;this is a    test&quot;</span><br><span class="line">this is a    test</span><br><span class="line"></span><br><span class="line">[lsjarch@LsjsArch test_quote]$ echo $(cal)</span><br><span class="line">一月 2022 一 二 三 四 五 六 日 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31</span><br><span class="line">[lsjarch@LsjsArch test_quote]$ echo &quot;$(cal)&quot;</span><br><span class="line">      一月 2022     </span><br><span class="line">一 二 三 四 五 六 日</span><br><span class="line">                1  2</span><br><span class="line"> 3  4  5  6  7  8  9</span><br><span class="line">10 11 12 13 14 15 16</span><br><span class="line">17 18 19 20 21 22 23</span><br><span class="line">24 25 26 27 28 29 30</span><br><span class="line">31</span><br></pre></td></tr></table></figure>
<p>理解第二个例子，事实上单词分割机制将换行符看作界定符，而这对命令替换产生了一个微妙的影响。前者实例没有引用的命令替换导致命令行包含40个参数，后者只有一个参数，参数内包括嵌入的空格和换行符。</p>
</li>
</ul>
</li>
<li>
<p>单引号</p>
<ul>
<li>
<p>要禁止所有的展开，就要使用单引号<code>' '</code>。理解下面这个例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_quote]$ echo text ~/*.txt &#123;a,b&#125; $(echo foo) $((1+1)) $USER</span><br><span class="line">text /home/lsjarch/*.txt a b foo 2 lsjarch</span><br><span class="line"></span><br><span class="line">[lsjarch@LsjsArch test_quote]$ echo &quot;text ~/*.txt &#123;a,b&#125; $(echo foo) $((1+1)) $USER&quot;</span><br><span class="line">text ~/*.txt &#123;a,b&#125; foo 2 lsjarch</span><br><span class="line"></span><br><span class="line">[lsjarch@LsjsArch test_quote]$ echo &#x27;text ~/*.txt &#123;a,b&#125; $(echo foo) $((1+1)) $USER&#x27;</span><br><span class="line">text ~/*.txt &#123;a,b&#125; $(echo foo) $((1+1)) $USER</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>随着引用的增强，越来越多的展开被禁止。</p>
</li>
</ul>
</li>
</ul>
<h3 id="7-9转义字符">7.9	转义字符</h3>
<p>使用转义字符可以消除文件名中一个特殊字符的含义，可以有地阻止展开：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_quote]$ echo &quot;The balance for user $USER is: \$50.00&quot;</span><br><span class="line">The balance for user lsjarch is: $50.00</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><em><strong>反斜杠转义字符序列：</strong></em></p>
<p><em>反斜杠作为转义字符外，也是一种表示法的一部分。这种表示法代表控制码，如ASCII编码表中前32个字符。</em></p>
<p><em>反斜杠表示法来自于C语言。<code>echo</code>命令带上<code>-e</code>选项，能够解释转义序列。</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 利用sleep命令和转义字符，创建一个简单倒数计数器</span></span><br><span class="line">[lsjarch@LsjsArch ~]$ sleep 10; echo -e &quot;Time&#x27;s up \a&quot;</span><br><span class="line">Time&#x27;s up </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以将转义序列放在$<span class="string">&#x27; &#x27;</span>中</span></span><br><span class="line">[lsjarch@LsjsArch ~]$ sleep 10; echo &quot;Time&#x27;s up&quot; $&#x27;\a&#x27;</span><br><span class="line">Time&#x27;s up </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7-10拓展阅读">7.10	拓展阅读</h3>
<ul>
<li>Bash 手册页有主要段落来讲述展开和引用，它们的介绍更高效准确；</li>
<li>Bash 参考手册也包含介绍展开和引用的章节：<a target="_blank" rel="noopener" href="https://www.gnu.org/software/bash/manual/bashref.html">https://www.gnu.org/software/bash/manual/bashref.html</a></li>
</ul>
<hr>
<h2 id="八、键盘高级操作技巧">八、键盘高级操作技巧</h2>
<p>命令行最重要的目标就是——懒，懒得只用简写英文单词作命令、用最少的击键次数完成最多的工作、手指不必离开键盘去使用鼠标。</p>
<p>本章命令：<code>clear</code>, <code>history</code>。</p>
<h3 id="8-1命令行编辑">8.1	命令行编辑</h3>
<p>Bash 使用了 Readline 库来实现命令行编辑，Readline 库是共享的线程集合，可以被不同的程序使用。</p>
<p>接下来，我们学习一些键盘操作。不过要注意，下面一些组合键可能会被GUI界面拦截，但使用虚拟控制台时所有按键组合都会正确工作。</p>
<h3 id="8-2移动光标">8.2	移动光标</h3>
<table>
<thead>
<tr>
<th>按键</th>
<th>行动</th>
</tr>
</thead>
<tbody>
<tr>
<td><kbd>ctrl</kbd>+<kbd>a</kbd></td>
<td>移动光标到行首</td>
</tr>
<tr>
<td><kbd>ctrl</kbd>+<kbd>e</kbd></td>
<td>移动光标到行尾</td>
</tr>
<tr>
<td><kbd>ctrl</kbd>+<kbd>f</kbd></td>
<td>光标前移一个字符，同右箭头</td>
</tr>
<tr>
<td><kbd>ctrl</kbd>+<kbd>b</kbd></td>
<td>光标后移一个字符，同左箭头</td>
</tr>
<tr>
<td><kbd>alt</kbd>+<kbd>f</kbd></td>
<td>光标前移一个字</td>
</tr>
<tr>
<td><kbd>alt</kbd>+<kbd>b</kbd></td>
<td>光标后移一个字</td>
</tr>
<tr>
<td><kbd>ctrl</kbd>+<kbd>l</kbd></td>
<td>清空屏幕，同<code>clear</code>命令</td>
</tr>
</tbody>
</table>
<h3 id="8-3修改文本">8.3	修改文本</h3>
<table>
<thead>
<tr>
<th>按键</th>
<th>行动</th>
</tr>
</thead>
<tbody>
<tr>
<td><kbd>ctrl</kbd>+<kbd>d</kbd></td>
<td>删除光标位置的字符</td>
</tr>
<tr>
<td><kbd>ctrl</kbd>+<kbd>t</kbd></td>
<td>光标位置的字符和光标前面的字符互换位置</td>
</tr>
<tr>
<td><kbd>alt</kbd>+<kbd>t</kbd></td>
<td>光标位置的字和其前面的字互换位置</td>
</tr>
<tr>
<td><kbd>alt</kbd>+<kbd>l</kbd></td>
<td>把从光标位置到字尾的字符转换成小写字符</td>
</tr>
<tr>
<td><kbd>alt</kbd>+<kbd>u</kbd></td>
<td>把从光标位置到字尾的字符转换成大写字符</td>
</tr>
</tbody>
</table>
<h3 id="8-4剪切和粘贴文本">8.4	剪切和粘贴文本</h3>
<p>Readline 文档使用术语<code>killing</code>和<code>yanking</code>来指我们常说的剪切和粘贴。剪切下来的文本被存储在一个叫做剪切环<code>kill-ring</code>的缓冲区中。</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>行动</th>
</tr>
</thead>
<tbody>
<tr>
<td><kbd>ctrl</kbd>+<kbd>k</kbd></td>
<td>剪切从光标位置到行尾的文本</td>
</tr>
<tr>
<td><kbd>ctrl</kbd>+<kbd>u</kbd></td>
<td>剪切从光标位置到行首的文本</td>
</tr>
<tr>
<td><kbd>alt</kbd>+<kbd>d</kbd></td>
<td>剪切从光标位置到词尾的文本</td>
</tr>
<tr>
<td><kbd>alt</kbd>+<kbd>backspace</kbd></td>
<td>剪切从光标位置到词头的文本。如果光标在一个单词的开头，则剪切前一个单词</td>
</tr>
<tr>
<td><kbd>ctrl</kbd>+<kbd>y</kbd></td>
<td>把剪切环中的文本粘贴到光标位置</td>
</tr>
</tbody>
</table>
<h3 id="8-5自动补全">8.5	自动补全</h3>
<p><kbd>tab</kbd>键可以完成键入命令时自动补全的工作。</p>
<p>自动补全不仅可以补全当前工作目录下包含已输入字符的唯一路径，还可以补全变量（需要以 $ 开头）、补全用户名（ ~ 开头）、补全命令、补全主机名（ @ 开头，并且包含在/etc/hosts 文件中）。</p>
<p><em>自动补全相关的组合键</em>：</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>行动</th>
</tr>
</thead>
<tbody>
<tr>
<td><kbd>alt</kbd>+<kbd>?</kbd></td>
<td>显示可能的自动补全列表。在大多数系统中，可以通过连按两次<kbd>tab</kbd>键来完成</td>
</tr>
<tr>
<td><kbd>alt</kbd>+<kbd>*</kbd></td>
<td>插入所有可能的自动补全。当需要使用多个匹配项时，非常有帮助</td>
</tr>
</tbody>
</table>
<p><strong>可编程自动补全：</strong></p>
<p>可编程自动补全允许加入额外的自动补全规则。通常，用来为一个命令的选项列表，或者一个应用程序支持的特殊文件类型加入自动补全，并且需要加入特定程序的支持。</p>
<p>可编程自动补全是由 shell 函数实现的，shell 函数是一种小巧的 shell 脚本，后面会学习到，现在，可以尝试下<code>set | less</code>来找到它们。</p>
<h3 id="8-6利用历史命令">8.6	利用历史命令</h3>
<p>bash 会维护家目录下<code>.bash_history</code>文件，其中保存着已经执行过的命令的历史列表，当然，是当前用户的；</p>
<h4 id="8-6-1搜索历史命令">8.6.1	搜索历史命令</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ history | less</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>默认情况下，bash 会保存最后输入的500个命令。</p>
<p>比如说，我们想要获取历史命令中有关目录 /usr/bin 内容的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ history | grep /usr/bin</span><br><span class="line">  284  ls -l /usr/bin &gt; test_io/ls-output.txt</span><br><span class="line">  298  ls -l /usr/bin &gt;&gt; ls-output.txt </span><br><span class="line">  300  ls -l /usr/bin 2&gt; ls-error.txt</span><br><span class="line">  302  ls -l /usr/bin 2&gt; ls-error.txt</span><br><span class="line">  338  ls -l /usr/bin | less</span><br><span class="line">  339  ls /bin /usr/bin | sort | less</span><br><span class="line">  340  ls /bin /usr/bin | sort | uniq | less</span><br><span class="line">  345  ls /bin /usr/bin | sort | uniq | wc </span><br><span class="line">  346  ls /bin /usr/bin | sort | uniq | grep zip</span><br><span class="line">  347  head -n 8 /usr/bin</span><br><span class="line">  349  ls -l /usr/bin &gt; ls-output.txt </span><br><span class="line">  353  ls /usr/bin | tail -n 5</span><br><span class="line">  357  ls /usr/bin | tee test_tee.txt | grep zip</span><br><span class="line">  359  ls /usr/bin | tee test_tee.txt | grep zip</span><br><span class="line">  407  file $(ls /usr/bin/* | grep zip)</span><br><span class="line">  449  history | grep /usr/bin</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第一个字段的数字表示这个命令在历史列表中的行号，随后在使用到<code>历史命令展开</code>时，我们会用到这个数字：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ !346</span><br><span class="line">ls /bin /usr/bin | sort | uniq | grep zip</span><br><span class="line">bunzip2</span><br><span class="line">bzip2</span><br><span class="line">bzip2recover</span><br><span class="line">gunzip</span><br><span class="line">gzip</span><br><span class="line">zipcmp</span><br><span class="line">zipmerge</span><br><span class="line">ziptool</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>bash 会将<code>!346</code>展开成历史列表中346行的内容。</p>
<p>bash 还具有按递增顺序来搜索历史列表的能力。即随着字符输入，我们可以一步步提高对历史列表的搜索能力。启动递增搜索：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ctrl+r，命令行会变成这样。提示符改变，表示我们正在执行反向递增搜索，即从“当前”向“过去某个时间段”的顺序搜索</span></span><br><span class="line">(reverse-i-search)`&#x27;: </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 之后输入要查找的文本，此处是 /usr/bin</span></span><br><span class="line">(reverse-i-search)`/usr/bin&#x27;: ls -l /usr/bin | less</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 按下 Enter 键即可执行这个命令，或者输入 ctrl+j，这个命令就会从历史命令中复制到当前命令行</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次输入 ctrl+r ，来找到下一个匹配项</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一些操作历史列表的键盘组合键：</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td><kbd>ctrl</kbd>+<kbd>p</kbd></td>
<td>移动到上一个历史条目，类似于上箭头键</td>
</tr>
<tr>
<td><kbd>ctrl</kbd>+<kbd>n</kbd></td>
<td>移动到下一个历史条目，类似于下箭头键</td>
</tr>
<tr>
<td><kbd>alt</kbd>+<kbd>&lt;</kbd></td>
<td>移动到历史列表开头</td>
</tr>
<tr>
<td><kbd>alt</kbd>+<kbd>&gt;</kbd></td>
<td>移动到历史列表结尾，即当前命令行</td>
</tr>
<tr>
<td><kbd>ctrl</kbd>+<kbd>r</kbd></td>
<td>反向递增搜索，从当前命令行开始，向上递增搜索</td>
</tr>
<tr>
<td><kbd>alt</kbd>+<kbd>p</kbd></td>
<td>反向搜索，但不是递增。输入查询字符串，按下Enter进行搜索</td>
</tr>
<tr>
<td><kbd>alt</kbd>+<kbd>n</kbd></td>
<td>向前搜索，非递增顺序</td>
</tr>
<tr>
<td><kbd>ctrl</kbd>+<kbd>o</kbd></td>
<td>执行历史列表中的当前项，并移到下一个。这对执行历史列表中的一系列命令非常方便</td>
</tr>
</tbody>
</table>
<h4 id="8-6-2展开历史命令">8.6.2	展开历史命令</h4>
<p>除了使用<code>！</code>字符可以展开对应行数的历史命令，还有：</p>
<table>
<thead>
<tr>
<th>序列</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>!!</td>
<td>重复最后一次执行的命令。可能按下上箭头键更简单些（</td>
</tr>
<tr>
<td>!number</td>
<td>重复历史列表中第 number 行的命令</td>
</tr>
<tr>
<td>!string</td>
<td>重复最近历史列表中，以这个字符串开头的命令</td>
</tr>
<tr>
<td>!?string</td>
<td>重复最近历史列表中，包含这个字符串的命令</td>
</tr>
</tbody>
</table>
<p>应该小心使用<code>!string</code>和<code>!?string</code>，除非你完全信任历史列表条目的内容。</p>
<p>历史展开机制比较晦涩，更多的说明可以参考 bash 手册页的 HISTORY EXPANSION 部分。</p>
<p>另外，除了 bash 中有命令历史特性，shell 会话也是可以被记录的。它们多是被 script 程序存储在一个文件中，其基本语法是<code>script [file]</code>，如果没有指定 file 名，则会使用文件 typesrcipt。查看 script 手册页，可以得到关于 script 程序选项和特点的完整列表</p>
<h3 id="8-7拓展阅读">8.7	拓展阅读</h3>
<ul>
<li>一篇关于计算机终端的好文章：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computer_terminal">https://en.wikipedia.org/wiki/Computer_terminal</a></li>
</ul>
<hr>
<h2 id="九、权限">九、权限</h2>
<p>传统Unix操作系统不同于MS-DOS系统，它是多任务多用户系统，即多个用户可以在同一时间使用同一台计算机，即使是远程用户通过SSH(secure shell)登录也可以操纵此电脑，只要该电脑连接到网络。</p>
<p>权限就是用来管理不同用户使用同一电脑的策略。除管理员用户外，普通用户行为既不能导致计算机崩溃，也不应该修改其他用户的文件。</p>
<p>本章命令：<code>id</code>, <code>chmod</code>, <code>umask</code>, <code>su</code>, <code>sudo</code> ,<code>chown</code>, <code>chgrp</code>, <code>passwd</code>。</p>
<h3 id="9-1拥有者，组成员，其他人">9.1	拥有者，组成员，其他人</h3>
<p>在Unix安全模型中，当一个用户拥有一个文件或目录时，用户对这个文件或目录的访问权限拥有控制权；而用户又属于若干用户组成的用户组，用户组成员由文件和目录的所有者授予的对文件和目录的访问权限。</p>
<p><code>id</code>：查找自己的身份信息；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ id</span><br><span class="line">用户id=1000(lsjarch) 组id=1000(lsjarch) 组=1000(lsjarch),998(wheel)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用户账户定义在<code>/etc/passwd</code>中，其中定义了用户名、uid、gid、帐号的真实姓名、家目录和登录shell，还有root用户(uid 0)的帐号以及各种各样的系统用户；</p>
<p>用户组定义在<code>/etc/group</code>中；</p>
<p>当用户账户和用户组创建后，这些文件随着<code>/etc/shadow</code>的变动而修改，<code>/etc/shadow</code>包含了关于用户密码的信息。</p>
<h3 id="9-2读取，写入，执行">9.2	读取，写入，执行</h3>
<p>文件和目录的访问权限由读访问、写访问、执行访问三项来定义。来看下权限的实现：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ mkdir test_authority</span><br><span class="line">[lsjarch@LsjsArch ~]$ cd test_authority</span><br><span class="line">[lsjarch@LsjsArch test_authority]$ &gt; test1.txt</span><br><span class="line">[lsjarch@LsjsArch test_authority]$ mkdir test2</span><br><span class="line">[lsjarch@LsjsArch test_authority]$ ln -s test1.txt test1.sym</span><br><span class="line"></span><br><span class="line">[lsjarch@LsjsArch test_authority]$ ls -l</span><br><span class="line">总用量 4</span><br><span class="line">lrwxrwxrwx 1 lsjarch lsjarch    9  1月  5 01:17 test1.sym -&gt; test1.txt</span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch    0  1月  5 01:06 test1.txt</span><br><span class="line">drwxr-xr-x 2 lsjarch lsjarch 4096  1月  5 01:16 test2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>ls -l</code>的结果列表第一字段，就表示了文件的属性。</p>
<p>之前学习到，第一个字符<code>-, d, l</code>分别 表示普通文件、目录、符号链接，要注意符号链接的文件属性总是<code>rwxrwxrwx</code>，事实上这是虚拟值，真正的文件属性是指符号链接所指向的文件的属性。第一个字符还可以是<code>c, b</code>，分别表示字符设备文件和块设备文件，字符设备文件是按照字节流来处理数据的设备，比如终端机、调制解调器；块设备文件是按照数据块来处理数据的设备，比如硬盘、CD-ROM盘。</p>
<p>之后九个字符，每三个一组，分别代表文件所有者、文件组所有者、其他人的读、写、执行的权限。设置权限后，rwx的权限属性会对文件或目录产生以下影响：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>文件</th>
<th>目录</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>允许打开并读取文件内容</td>
<td>允许列出目录中的内容，前提是目录必须设置了可执行属性 x</td>
</tr>
<tr>
<td>w</td>
<td>允许写入文件内容或截断文件，但是不允许对文件进行重命名或删除。重命名或删除是由目录的属性决定的</td>
<td>允许在目录下新建、删除或重命名文件，前提是目录必须设置了可执行属性 x</td>
</tr>
<tr>
<td>x</td>
<td>允许将文件作为程序来执行，使用脚本语言编写的程序必须设置为可读才能被执行</td>
<td>允许进入目录</td>
</tr>
</tbody>
</table>
<p>下面是权限属性的一些例子：</p>
<table>
<thead>
<tr>
<th>文件属性</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-rwx------</td>
<td>普通文件，对文件所有者来说可读、写、执行，其他人无法访问</td>
</tr>
<tr>
<td>-rw-------</td>
<td>普通文件，对文件所有者来说可读、写，其他人无法访问</td>
</tr>
<tr>
<td>-rw-r–r–</td>
<td>普通文件，对文件所有者来说可读、写，文件所有者的组成员可读，其他所有人也可读</td>
</tr>
<tr>
<td>-rwxr-xr-x</td>
<td>普通文件，对文件所有者来说可读、写、执行，也可以被组成员、其他所有人读、执行</td>
</tr>
<tr>
<td>-rw-rw----</td>
<td>普通文件，对文件所有者和文件所有者的组成员可读、写</td>
</tr>
<tr>
<td>lrwxrwxrwx</td>
<td>符号链接</td>
</tr>
<tr>
<td>drwxrwx—</td>
<td>目录，文件所有者及其组成员可以访问目录，且可以在目录下新建、删除、重命名文件</td>
</tr>
<tr>
<td>drwxr-x—</td>
<td>目录，文件所有者可以访问该目录并在目录下新建、删除、重命名文件，文件所有者的组成员可以访问目录，但不能新建、删除、重命名文件</td>
</tr>
</tbody>
</table>
<h3 id="9-3更改文件模式">9.3	更改文件模式</h3>
<p><code>chmod</code>：更改文件或目录的模式。只有文件所有者或超级用户才有权限修改文件或目录的模式。</p>
<p><code>chmod</code>支持八进制数字表示法和符号表示法两种方法来改变文件模式；</p>
<ul>
<li>
<p>八进制表示法：每个八进制数字代表了3个二进制数字，正好映射到文件的模式方案：</p>
<table>
<thead>
<tr>
<th>十进制</th>
<th>二进制</th>
<th>文件模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>000</td>
<td>—</td>
</tr>
<tr>
<td>1</td>
<td>001</td>
<td>–x</td>
</tr>
<tr>
<td>2</td>
<td>010</td>
<td>-w-</td>
</tr>
<tr>
<td>3</td>
<td>011</td>
<td>-wx</td>
</tr>
<tr>
<td>4</td>
<td>100</td>
<td>r–</td>
</tr>
<tr>
<td>5</td>
<td>101</td>
<td>r-x</td>
</tr>
<tr>
<td>6</td>
<td>110</td>
<td>rw-</td>
</tr>
<tr>
<td>7</td>
<td>111</td>
<td>rwx</td>
</tr>
</tbody>
</table>
<p>试着修改文件的权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 之前的权限</span></span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch    0  1月  5 01:06 test1.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改权限</span></span><br><span class="line">[lsjarch@LsjsArch test_authority]$ chmod 600 test1.txt </span><br><span class="line">[lsjarch@LsjsArch test_authority]$ ls -l test1.txt </span><br><span class="line">-rw------- 1 lsjarch lsjarch 0  1月  5 01:06 test1.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>符号表示法：其中有三个部分，更改会影响谁、要执行哪个操作、要设置哪种权限：</p>
<ul>
<li>
<p>指定要影响的对象：</p>
<table>
<thead>
<tr>
<th>影响对象</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>u</td>
<td>user的简写，意思是文件或目录的所有者</td>
</tr>
<tr>
<td>g</td>
<td>用户组</td>
</tr>
<tr>
<td>o</td>
<td>others的简写，意思是其他所有人</td>
</tr>
<tr>
<td>a</td>
<td>all的简写，是u、g、o的联合</td>
</tr>
</tbody>
</table>
<p>如果没有指定，则默认使用 all 。</p>
</li>
<li>
<p>执行的操作用 + 和 - 分别表示加上一个权限或减去一个权限，= 表示赋予权限；</p>
</li>
<li>
<p>符号表示法的实例：</p>
<table>
<thead>
<tr>
<th>符号表示</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>u+x</td>
<td>为文件所有者添加执行权限</td>
</tr>
<tr>
<td>u-x</td>
<td>删除文件所有者的执行权限</td>
</tr>
<tr>
<td>+x</td>
<td>为 all 添加可执行权限</td>
</tr>
<tr>
<td>o-rw</td>
<td>除了文件所有者和其用户组，，删除其他人的读写权限</td>
</tr>
<tr>
<td>go=rw</td>
<td>为群组的主人和任意文件拥有者的人赋予读写权限。如果群组的主人或全局之前已经有了执行权限，则会被移除</td>
</tr>
<tr>
<td>u+x,go=rw</td>
<td>给文件所有者执行权限并给组和其他人读和执行权限，多种设定用逗号分隔</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>符号表示法的优点之一在于，允许设置文件模式的单个组成部分的属性，而不影响其他部分。</p>
</li>
</ul>
</li>
</ul>
<p>最后来看一下<code>chmod</code>的文档吧：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_authority]$ chmod --help </span><br><span class="line">用法：chmod [选项]... 模式[,模式]... 文件...</span><br><span class="line">　或：chmod [选项]... 八进制模式 文件...</span><br><span class="line">　或：chmod [选项]... --reference=参考文件 文件...</span><br><span class="line">将每个文件的权限模式变更至指定模式。</span><br><span class="line">使用 --reference 选项时，把指定文件的模式设置为与参考文件相同。</span><br><span class="line"></span><br><span class="line">  -c, --changes             类似 verbose 选项，但仅在做出修改时进行报告</span><br><span class="line">  -f, --silent, --quiet     不显示大多数错误消息</span><br><span class="line">  -v, --verbose             输出各个处理的文件的诊断信息</span><br><span class="line">      --no-preserve-root    不特殊对待“/”（默认行为）</span><br><span class="line">      --preserve-root       不允许在“/”上递归操作</span><br><span class="line">      --reference=参考文件  使用参考文件的模式而非给定模式的值</span><br><span class="line">  -R, --recursive           递归修改文件和目录。但不总是如我们期望地有用，因为文件和目录的权限常常不是相同的</span><br><span class="line">      --help                显示此帮助信息并退出</span><br><span class="line">      --version             显示版本信息并退出</span><br><span class="line"></span><br><span class="line">每个模式字符串都应该匹配如下格式：&quot;[ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+&quot;。</span><br></pre></td></tr></table></figure>
<h3 id="9-4设置默认权限">9.4	设置默认权限</h3>
<p><code>umask</code>：在创建文件时控制文件的默认权限。使用八进制表示法来表达从文件模式属性中删除一个位掩码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_authority]$ ls</span><br><span class="line">test1.sym  test1.txt  test2</span><br><span class="line">[lsjarch@LsjsArch test_authority]$ umask </span><br><span class="line">0022</span><br><span class="line"><span class="meta">#</span><span class="bash"> 0022是当前<span class="built_in">umask</span>的八进制掩码值</span></span><br><span class="line"></span><br><span class="line">[lsjarch@LsjsArch test_authority]$ &gt; test_umask.txt</span><br><span class="line">[lsjarch@LsjsArch test_authority]$ ls -l test_umask.txt </span><br><span class="line">-rw-r--r-- 1 lsjarch lsjarch 0  1月  5 02:44 test_umask.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以看到，此时 test_umask.txt 的权限是文件所有者可以读写、用户组和其他用户只能读</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">现在，设置新的 <span class="built_in">umask</span> 值</span></span><br><span class="line">[lsjarch@LsjsArch test_authority]$ rm test_umask.txt </span><br><span class="line">[lsjarch@LsjsArch test_authority]$ umask 0000</span><br><span class="line">[lsjarch@LsjsArch test_authority]$ &gt; test_umask.txt</span><br><span class="line">[lsjarch@LsjsArch test_authority]$ ls -ls test_umask.txt </span><br><span class="line">0 -rw-rw-rw- 1 lsjarch lsjarch 0  1月  5 02:50 test_umask.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以看到，修改 <span class="built_in">umask</span> 的值后，新创建的 test_umask.txt 的权限与原先不同，变成了所有人都可读写</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>事实上，来看看掩码的八进制形式与权限的对应情况：</p>
<table>
<thead>
<tr>
<th>Original file mode</th>
<th>— rw- rw- rw-</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mask</td>
<td>000 000 010 010</td>
</tr>
<tr>
<td>Result</td>
<td>— rw- r-- r–</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>Original file mode</td>
<td>— rw- rw- rw-</td>
</tr>
<tr>
<td>Mask</td>
<td>000 000 000 000</td>
</tr>
<tr>
<td>Result</td>
<td>— rw- rw- rw-</td>
</tr>
</tbody>
</table>
<p>这下可以明显的看到，掩码中 1 会将对应位置上的属性删除。</p>
<p>最后，不要忘记清理现场：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch test_authority]$ rm test_umask.txt </span><br><span class="line">[lsjarch@LsjsArch test_authority]$ umask 0022</span><br><span class="line">[lsjarch@LsjsArch test_authority]$ umask</span><br><span class="line">0022</span><br></pre></td></tr></table></figure>
<p><strong>一些特殊权限</strong></p>
<p>虽然上面八进制的权限设置都使用三位表示，但技术上讲用四位表示更加确切，这是因为除了读、写、执行还有其他特殊权限：</p>
<ul>
<li>
<p><code>setuid</code>位：八进制为4000，作用是当应用到一个可执行文件时把有效用户ID从实际运行程序的用户设置成程序所有者的ID。</p>
<p>通常会应用到一些由超级用户所拥有的程序。当普通用户运行一个由超级用户所有的程序，且它已经设置了<code>setuid</code>位，则这个程序在运行时拥有超级用户的权限，可以访问普通用户禁止访问的文件或目录。显然，这可能引发安全问题，所以设置了<code>setuid</code>的程序数量必须尽量小；</p>
</li>
<li>
<p><code>setgid</code>位：八进制为2000，类似于<code>setuid</code>，只不过是将有效用户组ID从真正用户组ID修改为文件所有组的ID。</p>
<p>如果设置了一个目录的<code>setgid</code>位，则目录中新创建的文件具有这个目录用户组的所有权，而不是文件创建者所属用户组的所有权。对共享目录来说，当一个普通用户组中成员需要访问共享目录中的所有文件，而不管文件所有者的主用户组时，设置<code>setgid</code>位很有用；</p>
</li>
<li>
<p><code>sticky</code>位：八进制为1000，继承自Unix，这表示“不可交换的”。在Linux中，会忽略<code>sticky</code>位，但如果设置了则会阻止用户删除或重命名文件，除非用户是这个目录或文件的所有者、或是超级用户。这个位经常用来控制访问共享目录，如 /tmp。</p>
</li>
</ul>
<p>用<code>chmod</code>来设置特殊权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 首先，设置一个程序 setuid 权限</span></span><br><span class="line">chmod u+s program</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下一步，授予一个目录 setgid 权限</span></span><br><span class="line">chmod g+s dir</span><br><span class="line"><span class="meta">#</span><span class="bash"> 最后，授予一个目录 sticky 权限</span></span><br><span class="line">chmod +t dir</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当浏览 ls 命令的输出结果时，可以确定这些特殊权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置为 setuid 的程序</span></span><br><span class="line">-rwsr-xr-x</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置为 setgid 的目录</span></span><br><span class="line">drwxrwsr-x</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置为 sticky 的目录</span></span><br><span class="line">drwxrwxrwt</span><br></pre></td></tr></table></figure>
<h3 id="9-5更改身份">9.5	更改身份</h3>
<p>有三种方式可以更改身份：</p>
<ul>
<li>注销系统并以其他用户身份重新登录；</li>
<li>使用<code>su</code>命令：允许假定为另一个用户的身份并以该用户的ID启动一个新的shell会话，或者是以这个用户的身份发布一个命令；</li>
<li>使用<code>sudo</code>命令：允许一个管理员设置<code>/etc/sudoers</code>文件并定义一些具体可使用的命令，供当前身份用户获取管理员权限</li>
</ul>
<h3 id="9-6-su">9.6 <code>su</code></h3>
<p><code>su</code>：以其他用户身份和组ID来运行一个shell；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ su -h</span><br><span class="line"></span><br><span class="line">用法：</span><br><span class="line"> su [选项] [-] [&lt;用户&gt; [&lt;参数&gt;...]]</span><br><span class="line"></span><br><span class="line">Change the effective user ID and group ID to that of &lt;user&gt;.</span><br><span class="line">A mere - implies -l.  If &lt;user&gt; is not given, root is assumed.</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line"> -m, -p, --preserve-environment      不重置环境变量</span><br><span class="line"> -w, --whitelist-environment &lt;list&gt;  don&#x27;t reset specified variables</span><br><span class="line"></span><br><span class="line"> -g, --group &lt;组&gt;                指定主组</span><br><span class="line"> -G, --supp-group &lt;group&gt;        specify a supplemental group</span><br><span class="line"></span><br><span class="line"> -, -l, --login                  使 shell 成为登录 shell</span><br><span class="line"> -c, --command &lt;命令&gt;            使用 -c 向 shell 传递一条命令</span><br><span class="line"> --session-command &lt;命令&gt;        使用 -c 向 shell 传递一条命令而不创建新会话</span><br><span class="line"> -f, --fast                      向shell 传递 -f 选项(csh 或 tcsh)</span><br><span class="line"> -s, --shell &lt;shell&gt;             若 /etc/shells 允许，运行&lt;shell&gt;</span><br><span class="line"> -P, --pty                       create a new pseudo-terminal</span><br><span class="line"></span><br><span class="line"> -h, --help                      显示此帮助</span><br><span class="line"> -V, --version                   显示版本</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，如果包含<code>-l</code>选项，<code>su</code>会为指定用户启动一个需要登录的shell，这个选项可以简写为<code>-</code>；若没有指定用户，则默认是超级用户：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ su -</span><br><span class="line">密码： </span><br><span class="line">[root@LsjsArch ~]# </span><br><span class="line"></span><br><span class="line">[root@LsjsArch ~]# pwd</span><br><span class="line">/root</span><br><span class="line"></span><br><span class="line">[root@LsjsArch ~]# exit</span><br><span class="line">logout</span><br><span class="line">[lsjarch@LsjsArch ~]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，此处输入的密码是超级用户的密码，而不是当前用户的密码，这与<code>sudo</code>是不同的。之后，打开一个新的shell，切换到超级用户，此时的工作目录是超级用户的家目录<code>/root</code>。当完成工作后，输入<code>exit</code>退出超级用户，返回原来的shell。</p>
<p>也可以只执行单个命令，而不是启动一个新的可交互的shell：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ su -c &#x27;ls -l /root/*&#x27;</span><br><span class="line">密码： </span><br><span class="line">-rw-r--r-- 1 root root 1995219 12月 29 09:09 /root/qv2ray-git-3080.dac7ed16.r.-1-x86_64.pkg.tar.zst</span><br><span class="line">-rw-r--r-- 1 root root       0 12月 28 18:33 /root/visudo</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，需要将要执行的命令用单引号引起，因为我们需要这条命令在新的shell中展开，而不是当前shell。</p>
<h3 id="9-7sudo">9.7	<code>sudo</code></h3>
<p><code>sudo</code>：以另一个用户身份执行命令。</p>
<p><code>sudo</code>有一个不同于<code>su</code>的功能，即管理员能够配置<code>sudo</code>从而允许一个普通用户以不同身份通过一种非常可控的方式来执行命令，尤其是只有一个用户可以执行若干特殊命令时。另一大差异是<code>sudo</code>不需要管理员用户的密码，而是<strong>当前用户密码</strong>。</p>
<p><code>sudo</code>不会重新启动一个新的shell，也不会加载另一个用户的shell环境，意味着不用单引号将命令单独引起。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ sudo --help</span><br><span class="line">sudo - 以其他用户身份执行一条命令</span><br><span class="line"></span><br><span class="line">usage: sudo -h | -K | -k | -V</span><br><span class="line">usage: sudo -v [-ABknS] [-g group] [-h host] [-p prompt] [-u user]</span><br><span class="line">usage: sudo -l [-ABknS] [-g group] [-h host] [-p prompt] [-U user] [-u user] [command]</span><br><span class="line">usage: sudo [-ABbEHknPS] [-C num] [-D directory] [-g group] [-h host] [-p prompt] [-R directory] [-T timeout] [-u user]</span><br><span class="line">            [VAR=value] [-i|-s] [&lt;command&gt;]</span><br><span class="line">usage: sudo -e [-ABknS] [-C num] [-D directory] [-g group] [-h host] [-p prompt] [-R directory] [-T timeout] [-u user] file</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">  -A, --askpass                 使用助手程序进行密码提示</span><br><span class="line">  -b, --background              在后台运行命令</span><br><span class="line">  -B, --bell                    提示时响铃</span><br><span class="line">  -C, --close-from=num          关闭所有 &gt;= num 的文件描述符</span><br><span class="line">  -D, --chdir=directory         运行命令前改变工作目录</span><br><span class="line">  -E, --preserve-env            在执行命令时保留用户环境</span><br><span class="line">      --preserve-env=list       保留特定的环境变量</span><br><span class="line">  -e, --edit                    编辑文件而非执行命令</span><br><span class="line">  -g, --group=group             以指定的用户组或 ID 执行命令</span><br><span class="line">  -H, --set-home                将 HOME 变量设为目标用户的主目录</span><br><span class="line">  -h, --help                    显示帮助消息并退出</span><br><span class="line">  -h, --host=host               在主机上运行命令(如果插件支持)</span><br><span class="line">  -i, --login                   以目标用户身份运行一个登录 shell；可同时指定一条命令</span><br><span class="line">  -K, --remove-timestamp        完全移除时间戳文件</span><br><span class="line">  -k, --reset-timestamp         无效的时间戳文件</span><br><span class="line">  -l, --list                    列出用户权限或检查某个特定命令；对于长格式，使用两次</span><br><span class="line">  -n, --non-interactive         非交互模式，不提示</span><br><span class="line">  -P, --preserve-groups         保留组向量，而非设置为目标的组向量</span><br><span class="line">  -p, --prompt=prompt           使用指定的密码提示</span><br><span class="line">  -R, --chroot=directory        运行命令前改变根目录</span><br><span class="line">  -S, --stdin                   从标准输入读取密码</span><br><span class="line">  -s, --shell                   以目标用户运行 shell；可同时指定一条命令</span><br><span class="line">  -T, --command-timeout=timeout 在达到指定时间限制后终止命令</span><br><span class="line">  -U, --other-user=user         在列表模式中显示用户的权限</span><br><span class="line">  -u, --user=user               以指定用户或 ID 运行命令(或编辑文件)</span><br><span class="line">  -V, --version                 显示版本信息并退出</span><br><span class="line">  -v, --validate                更新用户的时间戳而不执行命令</span><br><span class="line">  --                            停止处理命令行参数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，通过添加选项<code>-l</code>可以了解<code>sudo</code>所授予的权限有哪些：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ sudo -l</span><br><span class="line">[sudo] lsjarch 的密码：</span><br><span class="line">用户 lsjarch 可以在 LsjsArch 上运行以下命令：</span><br><span class="line">    (ALL) ALL</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="9-8更改文件所有者和用户组">9.8	更改文件所有者和用户组</h3>
<p><code>chown</code>：用来更改文件或目录的所有者和用户组。使用这个命令需要超级用户权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ chown --help</span><br><span class="line">用法：chown [选项]... [所有者][:[组]] 文件...</span><br><span class="line">　或：chown [选项]... --reference=参考文件 文件...</span><br><span class="line">修改每个&lt;文件&gt;的所有者和/或所属组为给定的&lt;所有者&gt;和/或&lt;组&gt;。</span><br><span class="line">如同时使用 --reference，将每个给定&lt;文件&gt;的所有者和属组修改为&lt;参考文件&gt;</span><br><span class="line">所具有的对应值。</span><br><span class="line">  -c, --changes          类似 verbose 选项，但仅在做出修改时进行报告</span><br><span class="line">  -f, --silent, --quiet  不显示大多数错误消息</span><br><span class="line">  -v, --verbose          输出各个处理的文件的诊断信息</span><br><span class="line">      --dereference      影响每个符号链接的原始引用文件（这是默认行为），而非符号链接本身</span><br><span class="line">  -h, --no-dereference   只影响符号链接，而非被引用的任何文件(仅当系统支持更改符号链接的所有者时，该选项才有用）</span><br><span class="line">      --from=当前所有者:当前所属组</span><br><span class="line">                                只当每个文件的所有者和组符合选项所指定时才更改所</span><br><span class="line">                                有者和组。其中一个可以省略，这时已省略的属性就不</span><br><span class="line">                                需要符合原有的属性</span><br><span class="line">      --no-preserve-root  不特殊对待“/”（默认行为）</span><br><span class="line">      --preserve-root     不允许在“/”上递归操作</span><br><span class="line">      --reference=&lt;参考文件&gt;  使用指定&lt;参考文件&gt;的所有者和所属组信息，而非手工指定 所有者:组 的值</span><br><span class="line">  -R, --recursive        递归操作文件和目录</span><br><span class="line"></span><br><span class="line">以下选项是在指定了 -R 选项时被用于设置如何遍历目录结构体系。如果您指定了多于一个选项，那么只有最后一个会生效。</span><br><span class="line"></span><br><span class="line">  -H                     如果命令行参数是一个指向目录的符号链接，则对其</span><br><span class="line">                         进行遍历</span><br><span class="line">  -L                     遍历每一个遇到的指向目录的符号链接</span><br><span class="line">  -P                     不遍历任何符号链接（默认）</span><br><span class="line"></span><br><span class="line">      --help            显示此帮助信息并退出</span><br><span class="line">      --version         显示版本信息并退出</span><br><span class="line"></span><br><span class="line">如果没有指定所有者，则不会更改所有者信息。若所属组若没有指定也不会对其更改，但当加上 &#x27;:&#x27; 时 GROUP 会更改为指定所有者的主要组。所有者和所属组可以是</span><br><span class="line">数字或名称。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">  chown root /u         将 /u 的属主更改为&quot;root&quot;。</span><br><span class="line">  chown root:staff /u   和上面类似，但同时也将其属组更改为&quot;staff&quot;。</span><br><span class="line">  chown :staff /u       将其属组更改为&quot;staff&quot;，而属主不变</span><br><span class="line">  chown user_name: /u        属主改为用户&quot;user_name&quot;，属组改为用户&quot;user_name&quot;登录系统时所属的用户组</span><br><span class="line">  chown -hR root /u     将 /u 及其子目录下所有文件的属主更改为&quot;root&quot;。</span><br></pre></td></tr></table></figure>
<p>来看一个假想环境的实例吧：</p>
<p>假如当前有两个用户——janet，拥有超级用户访问权限；tony，一个普通用户。如果janet想要从她的家目录复制一个文件到tony的家目录，并且希望tony也能够编辑这个文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[janet@linuxbox ~]$ sudo cp myfile.txt ~tony</span><br><span class="line">Password:</span><br><span class="line">[janet@linuxbox ~]$ sudo ls -l ~tony/myfile.txt</span><br><span class="line">-rw-r--r-- 1 root root 8031 2008-03-20 14:30 /home/tony/myfile.txt</span><br><span class="line">[janet@linuxbox ~]$ sudo chown tony: ~tony/myfile.txt</span><br><span class="line">[janet@linuxbox ~]$ sudo ls -l ~tony/myfile.txt</span><br><span class="line">-rw-r--r-- 1 tony tony 8031 2008-03-20 14:30 /home/tony/myfile.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="9-9更改用户组所有权">9.9	更改用户组所有权</h3>
<p><code>chgrp</code>：更改用户组所有权。在旧Unix系统中，<code>chmod</code>只能修改文件所有权，而不是用户组所有权。而<code>chgrp</code>除了限制多一点外，用法和<code>chmod</code>几乎相同，而现代的Linux都支持使用<code>chmod</code>来更改文件所有者和用户组，故不赘述。</p>
<h3 id="9-10综合练习">9.10	综合练习</h3>
<p>依然假想9.8中的两个人——janet和tony，他们都有音乐CD收藏品，也都愿意设置一个共享目录。在这个共享目录中，他们分别以Ogg Vorbis或MP3的格式来存储他们的音乐文件，通过<code>sudo</code>命令，janet可以获取超级用户权限。</p>
<p>首先，janet创建一个以janet和tony为成员的用户组music：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[janet@linuxbox ~]$ sudo groupadd music</span><br><span class="line">[janet@linuxbox ~]$ sudo usermod -g janet music</span><br><span class="line">[janet@linuxbox ~]$ sudo usermod -g tony music</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下一步，janet创建了存储音乐文件的目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[janet@linuxbox ~]$ sudo mkdir /usr/local/share/Music</span><br><span class="line">password:</span><br><span class="line"></span><br><span class="line">[janet@linuxbox ~]$ ls -ld /usr/local/share/Music</span><br><span class="line">drwxr-xr-x 2 root root 4096 2008-03-21 18:05 /usr/local/share/Music</span><br></pre></td></tr></table></figure>
<p>可以看到，这个目录由root用户拥有，且权限属性为755，为了使该目录共享——允许tony写入，janet需要修改目录用户组的所有权和权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[janet@linuxbox ~]$ sudo chown :music /usr/local/share/Music</span><br><span class="line">[janet@linuxbox ~]$ sudo chmod 775 /usr/local/share/Music</span><br><span class="line">[janet@linuxbox ~]$ ls -ld /usr/local/share/Music</span><br><span class="line">drwxrwxr-x 2 root music 4096 2008-03-31 18:05 /usr/local/share/Music</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，<code>/usr/local/share/Music</code>目录由root用户拥有，允许用户组music的成员读取和写入，其他用户能够列出目录中内容但不能创建或修改内容。</p>
<p>但仍有一个问题，通过当前权限在<code>/usr/local/share/Music</code>中创建的文件，只具有用户janet和tony的普通权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[janet@linuxbox ~]$ &gt; /usr/local/share/Music/test_file</span><br><span class="line">[janet@linuxbox ~]$ ls -l /usr/local/share/Music/test_file</span><br><span class="line">-rw-r--r-- 1 janet janet 0 2008-03-24 20:03 test_file</span><br></pre></td></tr></table></figure>
<p>这是因为两个问题：</p>
<ul>
<li>
<p>系统默认的掩码是0022，这会禁止用户组成员编辑属于同组成员的文件。如果共享目录只包含文件，这就不是问题，但此时目录会存放音乐文件，通常音乐会根据艺术家和唱片的层次结构来组织分类，所以用户组成员需要在同组其他成员创建的目录中创建文件和目录。因此，我们应该将<code>umask</code>修改为0002；</p>
</li>
<li>
<p>用户组成员创建的文件和目录的用户组，将会设置为用户的主要组，而不是用户组music。这可以通过设置此目录的<code>setgid</code>位来解决：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[janet@linuxbox ~]$ sudo chmod g+s /usr/local/share/Music</span><br><span class="line">[janet@linuxbox ~]$ ls -ls /usr/local/share/Music</span><br><span class="line">drwxrwsr-x 2 root music 4096 2008-03-24 20:03 /usr/local/share/Music</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>最后，测试一下结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[janet@linuxbox ~]$ umask 0002</span><br><span class="line">[janet@linuxbox ~]$ rm /usr/local/share/Music/test_file</span><br><span class="line"></span><br><span class="line">[janet@linuxbox ~]$ &gt; /usr/local/share/Music/test_file</span><br><span class="line">[janet@linuxbox ~]$ mkdir /usr/local/share/Music/test_dir</span><br><span class="line">[janet@linuxbox ~]$ ls -l /usr/local/share/Music</span><br><span class="line">drwxrwsr-x 2 janet music 4096 2008-03-04 20:24 test_dir</span><br><span class="line">-rw-rw-r-- 1 janet music 0 2008-03-04 20:25 test_file</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，创建的文件和目录都具有正确的权限，允许用户组music的所有成员在目录<code>/usr/local/share/Music</code>中创建文件和目录。</p>
<p>需要注意的是，修改<code>umask</code>的值只在当前shell 会话中有效，若当前shell会话结束后，必须重新设置。</p>
<h3 id="9-11修改用户密码">9.11	修改用户密码</h3>
<p><code>passwd</code>：可以修改用户密码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ passwd</span><br><span class="line">为 lsjarch 更改 STRESS 密码。</span><br><span class="line">当前的密码： </span><br><span class="line">新的密码： </span><br><span class="line">重新输入新的密码： </span><br><span class="line">passwd：已成功更新密码</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该命令拒绝接受太短的密码、与先前密码相似的密码、字典中的单词作为的密码、太容易猜到的密码等。</p>
<p>如果具有超级用户权限，可以指定一个用户名作为<code>passwd</code>的参数，以设置另一个用户的密码。</p>
<p>最后，看下<code>passwd</code>的帮助文档吧：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ passwd --help</span><br><span class="line">用法：passwd [选项] [登录名]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">  -a, --all                     报告所有帐户的密码状态</span><br><span class="line">  -d, --delete                  删除指定帐户的密码</span><br><span class="line">  -e, --expire                  强制使指定帐户的密码过期</span><br><span class="line">  -h, --help                    显示此帮助信息并退出</span><br><span class="line">  -k, --keep-tokens             仅在过期后修改密码</span><br><span class="line">  -i, --inactive INACTIVE       密码过期后设置密码不活动为 INACTIVE</span><br><span class="line">  -l, --lock                    锁定指定的帐户</span><br><span class="line">  -n, --mindays MIN_DAYS        设置到下次修改密码所须等待的最短天数</span><br><span class="line">                                为 MIN_DAYS</span><br><span class="line">  -q, --quiet                   安静模式</span><br><span class="line">  -r, --repository REPOSITORY   在 REPOSITORY 库中改变密码</span><br><span class="line">  -R, --root CHROOT_DIR         chroot 到的目录</span><br><span class="line">  -S, --status                  报告指定帐户密码的状态</span><br><span class="line">  -u, --unlock                  解锁被指定帐户</span><br><span class="line">  -w, --warndays WARN_DAYS      设置过期警告天数为 WARN_DAYS</span><br><span class="line">  -x, --maxdays MAX_DAYS        设置到下次修改密码所须等待的最多天数为 MAX_DAYS</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="9-12拓展阅读">9.12	拓展阅读</h3>
<ul>
<li>一篇关于 malware （恶意软件）的文章：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Malware">https://en.wikipedia.org/wiki/Malware</a></li>
<li>一些命令行程序来创建和维护用户及用户组，请查看手册以了解：<code>adduser</code>, <code>useradd</code>, <code>groupadd</code>。</li>
</ul>
<hr>
<h2 id="十、进程">十、进程</h2>
<p>众所周知，多任务操作系统在宏观上并行，微观上串行。Linux内核通过使用进程，来安排不同的程序等待使用CPU，以管理多任务。</p>
<p>本章将学习一些可用的命令行工具，来帮助查看程序的执行状态，以及怎样终止行为不当的进程。</p>
<p>本章命令：<code>ps</code>, <code>top</code>, <code>jobs</code>, <code>bg</code>, <code>fg</code>, <code>kill</code>, <code>killall</code>, <code>shutdown</code>。</p>
<h3 id="10-1进程是怎样工作的？">10.1	进程是怎样工作的？</h3>
<ul>
<li>
<p>系统启动时，内核先把一些它自己的程序初始化为进程，然后运行一个叫做<code>init</code>的程序。</p>
</li>
<li>
<p><code>init</code>再运行一系列的称为<code>init脚本</code>的<code>shell脚本</code>，这些脚本位于<code>/etc</code>，它们可以启动所有的系统服务。</p>
</li>
<li>
<p>其中许多系统服务以守护程序(<code>daemon</code>)的形式实现，守护程序仅在后台运行，没有任何用户接口。这样，即使没用用户登录，系统也在运行例行事物。</p>
</li>
<li>
<p>一个程序可以发动另一个程序，通常表述为为一个父进程创建一个子进程。</p>
</li>
<li>
<p>内核维护每个进程的信息，以使事务有序。例如，系统分配给每个进程一个ID，通常称为PID，PID以升序分配，<code>init</code>进程的PID总是1。内核也对分配给每个进程的内存进行跟踪。</p>
</li>
<li>
<p>同文件一样，进程也有其所有者和用户ID、有效用户ID等。</p>
</li>
</ul>
<h3 id="10-2查看进程">10.2	查看进程</h3>
<p><code>ps</code>：最常用的查看进程的命令；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ ps</span><br><span class="line">    PID TTY          TIME CMD</span><br><span class="line">  16843 pts/1    00:00:00 bash</span><br><span class="line">  16845 pts/1    00:00:00 ps</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>ps</code>只会列出当前终端会话相关的进程，其中<code>TTY</code>是<code>Teletype</code>的简写，指进程的控制终端。<code>TIME</code>字段表示进程所消耗的CPU时间数量。</p>
<p>给<code>ps</code>加上选项，可以得到 更多关于系统运行状态的信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ ps x</span><br><span class="line">    PID TTY      STAT   TIME COMMAND</span><br><span class="line">    646 ?        Ss     0:00 /usr/lib/systemd/systemd --user</span><br><span class="line">    647 ?        S      0:00 (sd-pam)</span><br><span class="line">    657 ?        Sl     0:00 /usr/bin/kwalletd5 --pam-login 6 8</span><br><span class="line">    658 ?        Sl     0:00 /usr/bin/startplasma-x11</span><br><span class="line">    661 ?        Sl     0:11 fcitx5</span><br><span class="line">    664 ?        Rs     0:20 /usr/bin/dbus-daemon --session --address=systemd: --nofork --nopidfile --systemd-activation --sy</span><br><span class="line">    711 ?        Sl     0:12 /usr/bin/kded5</span><br><span class="line">    715 ?        Sl    10:11 /usr/bin/kwin_x11</span><br><span class="line">    734 ?        Ssl    0:01 /usr/bin/kglobalaccel5</span><br><span class="line">    750 ?        Ssl    0:00 /usr/lib/kactivitymanagerd</span><br><span class="line">    757 ?        Ssl    0:00 /usr/lib/dconf-service</span><br><span class="line">    771 ?        Sl     0:01 /usr/bin/ksmserver</span><br><span class="line">    806 ?        Sl     0:00 /usr/bin/xembedsniproxy</span><br><span class="line">    810 ?        Sl     0:02 /usr/lib/org_kde_powerdevil</span><br><span class="line">    812 ?        Sl     0:01 /usr/lib/polkit-kde-authentication-agent-1</span><br><span class="line">    814 ?        Sl     0:01 /usr/bin/kaccess</span><br><span class="line">    818 ?        Sl     0:07 /usr/bin/plasmashell</span><br><span class="line">	...</span><br><span class="line">	and many more...</span><br></pre></td></tr></table></figure>
<p>可以将<code>ps</code>的输出结果管道到<code>less</code>，这样可以方便浏览。</p>
<p><code>ps x</code>表示展示所有进程，不论它们由什么终端控制。<code>TTY</code>一栏中<code>?</code>表示没有控制终端。<code>STAT</code>是<code>state</code>的简写，表示进程当前的状态：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>R</td>
<td>进程正在运行或准备运行</td>
</tr>
<tr>
<td>S</td>
<td>进程睡眠。等待一个事件来唤醒</td>
</tr>
<tr>
<td>D</td>
<td>不可中断睡眠。进程正在等待I/O，比如磁盘驱动器的I/O</td>
</tr>
<tr>
<td>T</td>
<td>表示进程已停止运行</td>
</tr>
<tr>
<td>Z</td>
<td>僵尸进程，表示一个已经终止的子进程，但它的父进程还没有把子进程从进程表中删除</td>
</tr>
<tr>
<td>&lt;</td>
<td>一个高优先级进程，能够获取更多CPU资源，同样也会造成其他进程获取CPU时间变少，常被认为不好的进程<code>less nice</code></td>
</tr>
<tr>
<td>N</td>
<td>低优先级进程，只有当其他高优先级进程执行后才会得到CPU，常被认为好进程<code>nice</code></td>
</tr>
</tbody>
</table>
<p>状态符后可以跟其他字符，表示外来进程的特性。</p>
<p>另一个流行的选项组合是<code>ps aux</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ ps aux</span><br><span class="line">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root           1  0.0  0.0 102568 13216 ?        Ss   12:52   0:02 /usr/lib/systemd/systemd --system --deserialize 12</span><br><span class="line">root           2  0.0  0.0      0     0 ?        S    12:52   0:00 [kthreadd]</span><br><span class="line">root           3  0.0  0.0      0     0 ?        I&lt;   12:52   0:00 [rcu_gp]</span><br><span class="line">root           4  0.0  0.0      0     0 ?        I&lt;   12:52   0:00 [rcu_par_gp]</span><br><span class="line">root           6  0.0  0.0      0     0 ?        I&lt;   12:52   0:00 [kworker/0:0H-events_highpri]</span><br><span class="line">root           8  0.0  0.0      0     0 ?        I&lt;   12:52   0:00 [mm_percpu_wq]</span><br><span class="line">root          10  0.0  0.0      0     0 ?        S    12:52   0:00 [rcu_tasks_kthre]</span><br><span class="line">root          11  0.0  0.0      0     0 ?        S    12:52   0:00 [rcu_tasks_rude_]</span><br><span class="line">root          12  0.0  0.0      0     0 ?        S    12:52   0:00 [rcu_tasks_trace]</span><br><span class="line">root          13  0.0  0.0      0     0 ?        S    12:52   0:01 [ksoftirqd/0]</span><br><span class="line">root          14  0.0  0.0      0     0 ?        I    12:52   0:08 [rcu_preempt]</span><br><span class="line">root          15  0.0  0.0      0     0 ?        S    12:52   0:00 [rcub/0]</span><br><span class="line">root          16  0.0  0.0      0     0 ?        S    12:52   0:00 [rcuc/0]</span><br><span class="line">root          17  0.0  0.0      0     0 ?        S    12:52   0:00 [migration/0]</span><br><span class="line">root          18  0.0  0.0      0     0 ?        S    12:52   0:00 [idle_inject/0]</span><br><span class="line">root          19  0.0  0.0      0     0 ?        S    12:52   0:00 [cpuhp/0]</span><br><span class="line">root          20  0.0  0.0      0     0 ?        S    12:52   0:00 [cpuhp/1]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这会展示更多的信息：</p>
<table>
<thead>
<tr>
<th>标题</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>USER</td>
<td>用户ID，表示进程的所有者</td>
</tr>
<tr>
<td>%CPU</td>
<td>以百分比表示CPU的使用率</td>
</tr>
<tr>
<td>%MEM</td>
<td>以百分比表示内存的使用率</td>
</tr>
<tr>
<td>VSZ</td>
<td>虚拟内存的大小</td>
</tr>
<tr>
<td>RSS</td>
<td>进程占用的物理内存大小，以千字节为单位</td>
</tr>
<tr>
<td>START</td>
<td>进程运行的起始时间，若超过24小时，则用天表示</td>
</tr>
</tbody>
</table>
<h3 id="10-3-动态查看进程">10.3 动态查看进程</h3>
<p><code>top</code>：<code>ps</code>只是提供执行时刻系统状态的快照，而<code>top</code>能够看到更多动态信息；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top - 16:02:43 up  3:09,  1 user,  load average: 0.93, 0.99, 0.95</span><br><span class="line">任务: 277 total,   3 running, 274 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta">%</span><span class="bash">Cpu(s):  4.3 us,  2.2 sy,  0.0 ni, 92.9 id,  0.1 wa,  0.3 hi,  0.2 si,  0.0 st</span></span><br><span class="line">MiB Mem :  15852.7 total,  10311.1 free,   2270.6 used,   3270.9 buff/cache</span><br><span class="line">MiB Swap:   4096.0 total,   4096.0 free,      0.0 used.  12603.4 avail Mem </span><br><span class="line"></span><br><span class="line"> 进程号 USER      PR  NI    VIRT    RES    SHR    %CPU  %MEM     TIME+ COMMAND                                               </span><br><span class="line">  12675 lsjarch   20   0 5077572 599852 260504 R  33.2   3.7   0:57.55 GeckoMain                                             </span><br><span class="line">    482 root      20   0 1964320 103832  63400 S  13.0   0.6  12:59.90 Xorg                                                  </span><br><span class="line">    715 lsjarch   20   0 3438420 175456 121736 S  13.0   1.1  13:03.88 kwin_x11                                              </span><br><span class="line">  16826 lsjarch   20   0 1527504 133552 107244 S   9.3   0.8   0:14.79 konsole                                               </span><br><span class="line">   6867 lsjarch   20   0 1172776 355516 139720 S   6.0   2.2  12:15.49 qqmusic                                               </span><br><span class="line">    863 lsjarch    9 -11 1364988  15796  10888 S   2.3   0.1   4:52.42 pulseaudio                                            </span><br><span class="line">   4571 root      20   0 4932284  70380  19288 S   1.0   0.4   4:26.03 v2raya                                                </span><br><span class="line">   6456 root      20   0 6320064  59972  18896 S   1.0   0.4   2:50.04 v2ray                                                     </span><br><span class="line">   6859 lsjarch   20   0  307164  87100  68888 S   0.7   0.5   1:04.00 qqmusic                                               </span><br><span class="line">    461 dbus      20   0   15284   8080   5436 S   0.3   0.0   1:35.63 dbus-daemon                                           </span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<p><code>top</code>程序连续显示系统进程更新的信息（默认每三分钟一次）。这个命令是用来查看系统中的“顶端”进程的，其显示结果有两部分——系统概要和进程列表。进程列表以CPU使用率排序。来看看系统概要各字段的含义：</p>
<table>
<thead>
<tr>
<th>行号</th>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>top</td>
<td>程序名</td>
</tr>
<tr>
<td></td>
<td>16:02:43</td>
<td>当前时间</td>
</tr>
<tr>
<td></td>
<td>up 3:09</td>
<td>指计算机从上从启动到现在所运行的时间</td>
</tr>
<tr>
<td></td>
<td>1 user</td>
<td>有一个用户登录系统</td>
</tr>
<tr>
<td></td>
<td>load average:0.93, 0.99, 0.95</td>
<td>加载平均值，指等待运行的进程数目，即处于运行状态的进程个数，这些进程共享CPU。三个数值对应不同的时间周期，第一个是最后60秒的平均值，第二个数值是前5分钟的平均值，第三个数值是前15分钟的平均值。若平均值低于1.0，表示计算机工作不忙碌</td>
</tr>
<tr>
<td>2</td>
<td>任务：</td>
<td>总借了进程数目和各种进程状态</td>
</tr>
<tr>
<td>3</td>
<td>%Cpu(s):</td>
<td>描述了CPU正在执行的进程的特性</td>
</tr>
<tr>
<td></td>
<td>4.3us</td>
<td>表示4.3% of the CPU is being used for user process.这意味着进程在内核之外</td>
</tr>
<tr>
<td></td>
<td>2.2sy</td>
<td>2.2%的CPU时间被用于系统内核进程</td>
</tr>
<tr>
<td></td>
<td>0.0ni</td>
<td>0.0%的CPU时间被用于低优先级<code>nice</code>进程</td>
</tr>
<tr>
<td></td>
<td>92.9id</td>
<td>92.9%的CPU时间是空闲的</td>
</tr>
<tr>
<td></td>
<td>0.1wa</td>
<td>0.1%的CPU时间备用来等待I/O</td>
</tr>
<tr>
<td>4</td>
<td>MiB Mem</td>
<td>展示物理内存的使用情况</td>
</tr>
<tr>
<td>5</td>
<td>MiB Swap</td>
<td>展示交换分区（虚拟内存）的使用情况</td>
</tr>
</tbody>
</table>
<p><code>top</code>程序可以接受一系列键盘输入命令，其中<code>h</code>显示程序的帮助页面，<code>q</code>退出<code>top</code>程序。</p>
<p>虽然GUI界面都提供了CPU状态的图形化应用程序，但<code>top</code>优点是运行速度快且消耗系统资源更少。</p>
<h3 id="10-4控制进程">10.4	控制进程</h3>
<p>来进行一项控制进程的练习。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ kwrite</span><br></pre></td></tr></table></figure>
<p>如果没有kwrite，可以使用gedit等代替，不过这并不重要。输入上述命令后，屏幕上会打开一个窗口，并且没有shell提示符没有返回，这是因为shell在等待这个程序结束，如果关闭kwrite窗口，shell提示符就会返回。</p>
<p>下面开始操作：</p>
<ol>
<li>
<p><em>中断一个进程：</em></p>
<p>回到bash窗口，按下<kbd>ctrl</kbd>+<kbd>c</kbd>，中断当前程序(kwrite)的运行。我们会看到，kwrite窗口关闭，shell提示符返回。</p>
</li>
<li>
<p><em>把一个进程放置到后台：</em></p>
<p>如果我们想让shell提示符返回，但又不终止kwrite，即将其放置后台运行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ kwrite &amp;</span><br><span class="line">[1] 19536</span><br><span class="line">[lsjarch@LsjsArch ~]$</span><br></pre></td></tr></table></figure>
<p>信息<code>[1] 19536</code>表示启动了工作号为1、PID为19536的程序。此时运行ps命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ ps</span><br><span class="line">    PID TTY          TIME CMD</span><br><span class="line">  16843 pts/1    00:00:00 bash</span><br><span class="line">  19613 pts/1    00:00:00 kwrite</span><br><span class="line">  19634 pts/1    00:00:00 ps</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><em>工作控制：</em></p>
<p>这个shell功能可以列出从终端中启动的任务，执行<code>jobs</code>命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ jobs</span><br><span class="line">[1]+  运行中               kwrite &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>jobs</code>显示我们有一个编号为 1 的任务正在运行，其命令是kwrite &amp;</p>
</li>
<li>
<p><em>结果返回前台：</em></p>
<p>一个后台运行的进程不能获取shell中键盘的输入，也不能通过<kbd>ctrl</kbd>+<kbd>c</kbd>来中断，此时需要<code>fg</code>来让一个进程返回前台执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ jobs</span><br><span class="line">[1]+  运行中               kwrite &amp;</span><br><span class="line">[lsjarch@LsjsArch ~]$ fg %1</span><br><span class="line">kwrite</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中，<code>%1</code>称为 jobspec ，对于只有一个后台任务的情况 jobspec 可有可无，但多任务需要以此来准确控制进程。最后，输入<kbd>ctrl</kbd>+<kbd>c</kbd>中断程序。</p>
</li>
<li>
<p><em>停止一个进程：</em></p>
<p>停止一个进程而不是终止，即将前台进程移到后台等待，我们需要组合键<kbd>ctrl</kbd>+<kbd>z</kbd></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ kwrite</span><br><span class="line">^Z</span><br><span class="line">[1]+  已停止               kwrite</span><br><span class="line">[lsjarch@LsjsArch ~]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此时，打开GUI中的kwrite，我们发现无法对其操作，就像其死掉一样。通过<code>fg</code>命令，可以恢复程序到前台运行，或者用<code>bg</code>把程序移到后台。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ bg %1</span><br><span class="line">[1]+ kwrite &amp;</span><br><span class="line">[lsjarch@LsjsArch ~]$ </span><br></pre></td></tr></table></figure>
</li>
<li>
<p><em>为什么要从命令行启动程序呢？</em></p>
<ul>
<li>有时所要启动的程序没有在窗口管理器的菜单列出来；</li>
<li>从命令行启动程序可以看到运行中的错误信息，而窗口系统不能看到；</li>
<li>有可能从图形界面菜单中启动不了，而从命令行界面启动可以了解其错误信息。</li>
</ul>
</li>
</ol>
<h3 id="10-5Signals">10.5	Signals</h3>
<p><code>kill</code>：杀死需要终止的程序；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ jobs </span><br><span class="line">[1]+  运行中               kwrite &amp;</span><br><span class="line">[lsjarch@LsjsArch ~]$ ps </span><br><span class="line">    PID TTY          TIME CMD</span><br><span class="line">  16843 pts/1    00:00:00 bash</span><br><span class="line">  20540 pts/1    00:00:01 kwrite</span><br><span class="line">  20850 pts/1    00:00:00 ps</span><br><span class="line">[lsjarch@LsjsArch ~]$ kill 20540</span><br><span class="line">[lsjarch@LsjsArch ~]$ ps</span><br><span class="line">    PID TTY          TIME CMD</span><br><span class="line">  16843 pts/1    00:00:00 bash</span><br><span class="line">  20853 pts/1    00:00:00 ps</span><br><span class="line">[1]+  已终止               kwrite</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>准确说，<code>kill</code>不是杀死程序，而是给程序发送信号。信号是程序与操作系统进行通信的手段之一。我们之前使用组合键操作终端时，终端会给前端运行的程序发送一个信号，<kbd>ctrl</kbd>+<kbd>c</kbd>是INT中断信号，<kbd>ctrl</kbd>+<kbd>z</kbd>是TSTP终端停止信号。程序接受到信号后作出相应响应，比如，接收终止信号后保存当前工作并退出。</p>
<h3 id="10-6通过kill给进程发送信号">10.6	通过<code>kill</code>给进程发送信号</h3>
<p><code>kill</code>发送信号的语法类似这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill [-signal] PID...</span><br></pre></td></tr></table></figure>
<p>如果命令行中没有指定信号，则默认发送TERM终止信号，而其他信号含义是：</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>名字</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>HUP</td>
<td>挂起。发送这个信号到终端机上的前台程序，程序会终止。许多守护进程也使用这个信号来重新初始化。这表明，当发送这个信号到一个守护进程后，这个进程会重新启动，并重新读取它的配置文件。</td>
</tr>
<tr>
<td>2</td>
<td>INT</td>
<td>中断。<kbd>ctrl</kbd>+<kbd>c</kbd>一样的功能，通常会终止一个程序</td>
</tr>
<tr>
<td>9</td>
<td>KILL</td>
<td>杀死。事实上，并不是发送KILL信号到目标进程，而是内核立刻终止这个进程，当一个进程以这种方式终止时，没有机会去做清理工作，因此要慎用</td>
</tr>
<tr>
<td>15</td>
<td>TERM</td>
<td>终止。<code>kill</code>的默认信号，如果程序仍然“活着”，可以接受信号，那么程序终止。</td>
</tr>
<tr>
<td>18</td>
<td>CONT</td>
<td>继续。在停止一段时间后，进程恢复运行</td>
</tr>
<tr>
<td>19</td>
<td>STOP</td>
<td>停止。类似于KILL信号，不是发送给进程，因此不能被进程忽略。这个信号将导致进程停止运行，而不是终止。</td>
</tr>
</tbody>
</table>
<p>来用实验理解：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ kwrite &amp;</span><br><span class="line">[1] 22269</span><br><span class="line">[lsjarch@LsjsArch ~]$ kill -1 22269</span><br><span class="line">[lsjarch@LsjsArch ~]$ ps</span><br><span class="line">    PID TTY          TIME CMD</span><br><span class="line">  16843 pts/1    00:00:00 bash</span><br><span class="line">  23368 pts/1    00:00:00 ps</span><br><span class="line">[1]+  挂起                  kwrite</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 还可以用名字指定要发送的信号，不过要在名字前加上<span class="string">&quot;SIG&quot;</span></span></span><br><span class="line">[lsjarch@LsjsArch ~]$ kwrite &amp;</span><br><span class="line">[1] 23431</span><br><span class="line">[lsjarch@LsjsArch ~]$ ps</span><br><span class="line">    PID TTY          TIME CMD</span><br><span class="line">  16843 pts/1    00:00:00 bash</span><br><span class="line">  23431 pts/1    00:00:00 kwrite</span><br><span class="line">  23467 pts/1    00:00:00 ps</span><br><span class="line">[lsjarch@LsjsArch ~]$ kill -SIGHUP 23431</span><br><span class="line">[lsjarch@LsjsArch ~]$ ps</span><br><span class="line">    PID TTY          TIME CMD</span><br><span class="line">  16843 pts/1    00:00:00 bash</span><br><span class="line">  23607 pts/1    00:00:00 ps</span><br><span class="line">[1]+  挂起                  kwrite</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>试着用其他信号重复上述实验。</p>
<p>进程和文件一样，拥有所有者，所以为了能够通过<code>kill</code>命令来给进程发送信号，必须是进程的所有者或超级用户。</p>
<p><em>其他系统频繁使用的信号</em></p>
<table>
<thead>
<tr>
<th>编号</th>
<th>名字</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>QUIT</td>
<td>退出</td>
</tr>
<tr>
<td>11</td>
<td>SEGV</td>
<td>段错误。如果一个程序非法使用内存，就会发送这个信号</td>
</tr>
<tr>
<td>20</td>
<td>TSTP</td>
<td>终端停止。按下<kbd>ctrl</kbd>+<kbd>z</kbd>组合键，中断发送至进程。但与STOP信号不同，TSTP信号由目标进程接收且可能被忽略</td>
</tr>
<tr>
<td>28</td>
<td>WINCH</td>
<td>改变窗口大小。当改变窗口大小时，系统会发送这个信号，像<code>top</code>和<code>less</code>会响应这个信号并刷新现实的内容</td>
</tr>
</tbody>
</table>
<p>实际上，完整的信号列表有：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ kill -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="10-7给多个进程发送信号">10.7	给多个进程发送信号</h3>
<p><code>killall</code>：给匹配特定程序或用户名的多个进程发送信号；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">killall [-u user] [-signal] name...</span><br></pre></td></tr></table></figure>
<p>来测试一下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lsjarch@LsjsArch ~]$ kwrite &amp;</span><br><span class="line">[1] 23773</span><br><span class="line">[lsjarch@LsjsArch ~]$ kwrite &amp;</span><br><span class="line">[2] 23801</span><br><span class="line"></span><br><span class="line">[lsjarch@LsjsArch ~]$ ps </span><br><span class="line">    PID TTY          TIME CMD</span><br><span class="line">  16843 pts/1    00:00:00 bash</span><br><span class="line">  23773 pts/1    00:00:00 kwrite</span><br><span class="line">  23801 pts/1    00:00:00 kwrite</span><br><span class="line">  23826 pts/1    00:00:00 ps</span><br><span class="line">[lsjarch@LsjsArch ~]$ killall kwrite</span><br><span class="line">[lsjarch@LsjsArch ~]$ ps</span><br><span class="line">    PID TTY          TIME CMD</span><br><span class="line">  16843 pts/1    00:00:00 bash</span><br><span class="line">  23844 pts/1    00:00:00 ps</span><br><span class="line">[1]-  已终止               kwrite</span><br><span class="line">[2]+  已终止               kwrite</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="10-8更多和进程相关的命令">10.8	更多和进程相关的命令</h3>
<table>
<thead>
<tr>
<th>命令名</th>
<th>命令描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pstree</td>
<td>输出一个树型结构的进程列表，这个列表展示了进程间父/子关系</td>
</tr>
<tr>
<td>vmstat</td>
<td>输出一个系统资源使用快照，包括内存、交换分区、磁盘I/O。为了看到连续的显示结果，可以在命令名后加上延时时间(单位：秒)。如<code>vmstat 5</code></td>
</tr>
<tr>
<td>xload</td>
<td>一个图形界面程序，可以画出系统负载的图形</td>
</tr>
<tr>
<td>tload</td>
<td>在终端中画出图形</td>
</tr>
</tbody>
</table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:chestnut_lsj@foxmail.com">chestNut_Lsj</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://chestnutlsj.github.io/2022/01/06/Linux-Shell-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://chestnutlsj.github.io/2022/01/06/Linux-Shell-学习笔记/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://chestNutLsj.github.io" target="_blank">chestNut_Lsj's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Shell/">Shell</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="/img/violet3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2022/01/07/Hello-World/"><img class="prev-cover" src="/img/loading.gif" data-original="/img/violet3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Hello, World!</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Linux Shell学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFshell%EF%BC%9F"><span class="toc-text">一、什么是shell？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E7%BB%88%E7%AB%AF%E4%BB%BF%E7%9C%9F%E5%99%A8"><span class="toc-text">1.1	终端仿真器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E5%90%AF%E5%8A%A8"><span class="toc-text">1.2	启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%E6%96%B9%E5%90%91%E9%94%AE%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">1.3	方向键的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4%E9%BC%A0%E6%A0%87%E4%BD%9C%E7%94%A8"><span class="toc-text">1.4	鼠标作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5%E5%B0%9D%E8%AF%95%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4"><span class="toc-text">1.5	尝试一些简单命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6%E8%99%9A%E6%8B%9F%E7%BB%88%E7%AB%AF"><span class="toc-text">1.6	虚拟终端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7%E6%8B%93%E5%B1%95%E9%98%85%E8%AF%BB"><span class="toc-text">1.7	拓展阅读</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E8%B7%B3%E8%BD%AC"><span class="toc-text">二、文件系统中跳转</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E7%90%86%E8%A7%A3%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%91"><span class="toc-text">2.1	理解文件系统树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E5%BD%93%E5%89%8D%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95"><span class="toc-text">2.2	当前工作目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E5%88%97%E5%87%BA%E7%9B%AE%E5%BD%95%E5%86%85%E5%AE%B9"><span class="toc-text">2.3	列出目录内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%E5%88%87%E6%8D%A2%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95"><span class="toc-text">2.4	切换当前目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5Linux%E6%96%87%E4%BB%B6%E5%90%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%84%E5%88%99"><span class="toc-text">2.5	Linux文件名的一些规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%8E%A2%E7%B4%A2Linux"><span class="toc-text">三、探索Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1ls%E6%B7%B1%E5%85%A5"><span class="toc-text">3.1	ls深入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E9%80%89%E9%A1%B9%E5%92%8C%E5%8F%82%E6%95%B0"><span class="toc-text">3.2	选项和参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E6%B7%B1%E7%A9%B6%E9%95%BF%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA"><span class="toc-text">3.3	深究长格式输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4%E7%A1%AE%E5%AE%9A%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.4	确定文件类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5%E6%B5%8F%E8%A7%88%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-text">3.5	浏览文件内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6%E5%BC%80%E5%A7%8B%E6%8E%A2%E7%B4%A2Linux%E5%90%A7%EF%BC%81"><span class="toc-text">3.6	开始探索Linux吧！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5"><span class="toc-text">3.7	符号链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8%E6%8B%93%E5%B1%95%E9%98%85%E8%AF%BB"><span class="toc-text">3.8	拓展阅读</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95"><span class="toc-text">四、操作文件和目录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">4.1	通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95"><span class="toc-text">4.2	创建目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95"><span class="toc-text">4.3	复制文件和目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4%E7%A7%BB%E5%8A%A8%E5%92%8C%E9%87%8D%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6"><span class="toc-text">4.4	移动和重命名文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95"><span class="toc-text">4.5	删除文件和目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6%E5%88%9B%E5%BB%BA%E9%93%BE%E6%8E%A5"><span class="toc-text">4.6	创建链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7%E7%BB%83%E4%B9%A0%E4%B8%80%E4%B8%8B"><span class="toc-text">4.7	练习一下</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">五、使用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E5%91%BD%E4%BB%A4%EF%BC%9F"><span class="toc-text">5.1	到底什么是命令？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E8%AF%86%E5%88%AB%E5%91%BD%E4%BB%A4"><span class="toc-text">5.2	识别命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3%E8%8E%B7%E5%BE%97%E5%91%BD%E4%BB%A4%E6%96%87%E6%A1%A3"><span class="toc-text">5.3	获得命令文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4%E6%98%BE%E7%A4%BA%E7%94%A8%E6%B3%95%E4%BF%A1%E6%81%AF"><span class="toc-text">5.4	显示用法信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5%E6%98%BE%E7%A4%BA%E7%A8%8B%E5%BA%8F%E6%89%8B%E5%86%8C%E9%A1%B5"><span class="toc-text">5.5	显示程序手册页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6%E6%98%BE%E7%A4%BA%E9%80%82%E5%BD%93%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-text">5.6	显示适当的命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7%E6%98%BE%E7%A4%BA%E9%9D%9E%E5%B8%B8%E7%AE%80%E6%B4%81%E7%9A%84%E5%91%BD%E4%BB%A4%E8%AF%B4%E6%98%8E"><span class="toc-text">5.7	显示非常简洁的命令说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8%E6%98%BE%E7%A4%BA%E7%A8%8B%E5%BA%8F-Info-%E6%9D%A1%E7%9B%AE"><span class="toc-text">5.8	显示程序 Info 条目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-9README%E5%92%8C%E5%85%B6%E4%BB%96%E7%A8%8B%E5%BA%8F%E6%96%87%E6%A1%A3"><span class="toc-text">5.9	README和其他程序文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-10%E7%94%A8%E5%88%AB%E5%90%8D%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-text">5.10	用别名创建自己的命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-11%E6%8B%93%E5%B1%95%E9%98%85%E8%AF%BB"><span class="toc-text">5.11	拓展阅读</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81I-O%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">六、I&#x2F;O重定向</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%E3%80%81%E9%94%99%E8%AF%AF"><span class="toc-text">6.1	标准输入、输出、错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2%E9%87%8D%E5%AE%9A%E5%90%91%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA"><span class="toc-text">6.2	重定向标准输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3%E9%87%8D%E5%AE%9A%E5%90%91%E6%A0%87%E5%87%86%E9%94%99%E8%AF%AF"><span class="toc-text">6.3	重定向标准错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4%E9%87%8D%E5%AE%9A%E5%90%91%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5"><span class="toc-text">6.4	重定向标准输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5%E7%AE%A1%E9%81%93%E7%BA%BF"><span class="toc-text">6.5	管道线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-text">6.6	过滤器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7%E6%8A%A5%E9%81%93%E6%88%96%E5%BF%BD%E7%95%A5%E9%87%8D%E5%A4%8D%E8%A1%8C"><span class="toc-text">6.7	报道或忽略重复行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8%E6%89%93%E5%8D%B0%E8%A1%8C%EF%BC%8C%E5%AD%97%E8%8A%82%E5%92%8C%E5%AD%97%E8%8A%82%E6%95%B0"><span class="toc-text">6.8	打印行，字节和字节数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9%E6%89%93%E5%8D%B0%E5%8C%B9%E9%85%8D%E8%A1%8C"><span class="toc-text">6.9	打印匹配行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10%E6%89%93%E5%8D%B0%E6%96%87%E4%BB%B6%E5%BC%80%E5%A4%B4-%E7%BB%93%E5%B0%BE%E9%83%A8%E5%88%86"><span class="toc-text">6.10	打印文件开头&#x2F;结尾部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-11%E4%BB%8E-stdin-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%B9%B6%E5%90%8C%E6%97%B6%E8%BE%93%E5%87%BA%E5%88%B0-stdout-%E5%92%8C%E6%96%87%E4%BB%B6"><span class="toc-text">6.11	从 stdin 读取数据，并同时输出到 stdout 和文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81shell-%E4%B8%AD%E7%9A%84%E5%B1%95%E5%BC%80%E6%A8%A1%E5%BC%8F"><span class="toc-text">七、shell 中的展开模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1%E5%AD%97%E7%AC%A6%E5%B1%95%E5%BC%80"><span class="toc-text">7.1	字符展开</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2%E8%B7%AF%E5%BE%84%E5%90%8D%E5%B1%95%E5%BC%80"><span class="toc-text">7.2	路径名展开</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3%E6%B3%A2%E6%B5%AA%E7%BA%BF%E5%B1%95%E5%BC%80"><span class="toc-text">7.3	波浪线展开</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4%E7%AE%97%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B1%95%E5%BC%80"><span class="toc-text">7.4	算数表达式展开</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5%E8%8A%B1%E6%8B%AC%E5%8F%B7%E5%B1%95%E5%BC%80"><span class="toc-text">7.5	花括号展开</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6%E5%8F%82%E6%95%B0%E5%B1%95%E5%BC%80"><span class="toc-text">7.6	参数展开</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7%E5%91%BD%E4%BB%A4%E6%9B%BF%E6%8D%A2"><span class="toc-text">7.7	命令替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8%E5%BC%95%E7%94%A8"><span class="toc-text">7.8	引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-9%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-text">7.9	转义字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-10%E6%8B%93%E5%B1%95%E9%98%85%E8%AF%BB"><span class="toc-text">7.10	拓展阅读</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E9%94%AE%E7%9B%98%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7"><span class="toc-text">八、键盘高级操作技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96%E8%BE%91"><span class="toc-text">8.1	命令行编辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2%E7%A7%BB%E5%8A%A8%E5%85%89%E6%A0%87"><span class="toc-text">8.2	移动光标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3%E4%BF%AE%E6%94%B9%E6%96%87%E6%9C%AC"><span class="toc-text">8.3	修改文本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4%E5%89%AA%E5%88%87%E5%92%8C%E7%B2%98%E8%B4%B4%E6%96%87%E6%9C%AC"><span class="toc-text">8.4	剪切和粘贴文本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8"><span class="toc-text">8.5	自动补全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6%E5%88%A9%E7%94%A8%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4"><span class="toc-text">8.6	利用历史命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-1%E6%90%9C%E7%B4%A2%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4"><span class="toc-text">8.6.1	搜索历史命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-2%E5%B1%95%E5%BC%80%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4"><span class="toc-text">8.6.2	展开历史命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7%E6%8B%93%E5%B1%95%E9%98%85%E8%AF%BB"><span class="toc-text">8.7	拓展阅读</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%9D%83%E9%99%90"><span class="toc-text">九、权限</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1%E6%8B%A5%E6%9C%89%E8%80%85%EF%BC%8C%E7%BB%84%E6%88%90%E5%91%98%EF%BC%8C%E5%85%B6%E4%BB%96%E4%BA%BA"><span class="toc-text">9.1	拥有者，组成员，其他人</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2%E8%AF%BB%E5%8F%96%EF%BC%8C%E5%86%99%E5%85%A5%EF%BC%8C%E6%89%A7%E8%A1%8C"><span class="toc-text">9.2	读取，写入，执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3%E6%9B%B4%E6%94%B9%E6%96%87%E4%BB%B6%E6%A8%A1%E5%BC%8F"><span class="toc-text">9.3	更改文件模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E6%9D%83%E9%99%90"><span class="toc-text">9.4	设置默认权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5%E6%9B%B4%E6%94%B9%E8%BA%AB%E4%BB%BD"><span class="toc-text">9.5	更改身份</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6-su"><span class="toc-text">9.6 su</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-7sudo"><span class="toc-text">9.7	sudo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-8%E6%9B%B4%E6%94%B9%E6%96%87%E4%BB%B6%E6%89%80%E6%9C%89%E8%80%85%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84"><span class="toc-text">9.8	更改文件所有者和用户组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-9%E6%9B%B4%E6%94%B9%E7%94%A8%E6%88%B7%E7%BB%84%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-text">9.9	更改用户组所有权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-10%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0"><span class="toc-text">9.10	综合练习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-11%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81"><span class="toc-text">9.11	修改用户密码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-12%E6%8B%93%E5%B1%95%E9%98%85%E8%AF%BB"><span class="toc-text">9.12	拓展阅读</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E8%BF%9B%E7%A8%8B"><span class="toc-text">十、进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1%E8%BF%9B%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="toc-text">10.1	进程是怎样工作的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B"><span class="toc-text">10.2	查看进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E5%8A%A8%E6%80%81%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B"><span class="toc-text">10.3 动态查看进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4%E6%8E%A7%E5%88%B6%E8%BF%9B%E7%A8%8B"><span class="toc-text">10.4	控制进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5Signals"><span class="toc-text">10.5	Signals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-6%E9%80%9A%E8%BF%87kill%E7%BB%99%E8%BF%9B%E7%A8%8B%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="toc-text">10.6	通过kill给进程发送信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-7%E7%BB%99%E5%A4%9A%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="toc-text">10.7	给多个进程发送信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-8%E6%9B%B4%E5%A4%9A%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-text">10.8	更多和进程相关的命令</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By chestNut_Lsj</div><div class="framework-info"><span>框架 </span><a href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to My <a href="https://chestnutlsj.github.io">Secret Base!</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'f7a82b72bad36bc545fe',
      clientSecret: '2c675361c1d2ac8f4e7bd3270f786c7d1493f858',
      repo: 'https://github.com/chestNutLsj/blogGitalk',
      owner: 'chestNut_Lsj',
      admin: [''],
      id: '296a337b0704e9c21263032b24dee8e1',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><link rel="stylesheet" href="/css/scroll_bars.css"><div class="aplayer no-destroy" data-id="7226353845" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="true" data-order="list" data-preload="auto" data-autoplay="true" muted></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="true" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},t.src!==i&&(n.src=i)}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body></html>